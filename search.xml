<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World!</title>
    <url>/2024/05/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<p>hexo g -d： 生成并上传</p>
]]></content>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>20250309拼多多笔试算法练习</title>
    <url>/2025/03/13/%E7%AE%97%E6%B3%95%E9%A2%98/20250309%E6%8B%BC%E5%A4%9A%E5%A4%9A%E7%AC%94%E8%AF%95%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p>做题地址：<a href="https://oj.niumacode.com/training/37/problems">https://oj.niumacode.com/training/37/problems</a></p>
<span id="more"></span>

<h2 id="20250309-1-传送门1"><a href="#20250309-1-传送门1" class="headerlink" title="20250309_1_传送门1"></a>20250309_1_传送门1</h2><p>签到题：先选负的值，再反转，再加上正的值。<br>也就是求所有数的绝对值之和</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        ans += <span class="built_in">abs</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20250309-2-传送门2"><a href="#20250309-2-传送门2" class="headerlink" title="20250309_2_传送门2"></a>20250309_2_传送门2</h2><p>动态规划，依次使用传送门，任意时刻反转</p>
<ul>
<li>定义状态<ul>
<li><code>dp[i][0][0]</code>：用到第i个传送门，用了0次反转到0点的最大距离</li>
<li><code>dp[i][0][1]</code>：用到第i个传送门，用了0次反转到0点的最小距离</li>
<li><code>dp[i][1][0]</code>：用到第i个传送门，用了1次反转到0点的最大距离</li>
<li><code>dp[i][1][1]</code>：用到第i个传送门，用了1次反转到0点的最小距离</li>
</ul>
</li>
<li>状态转移方程<ul>
<li><code>dp[i][0][0] = dp[i - 1][0][0] + a[i];</code></li>
<li><code>dp[i][0][1] = dp[i - 1][0][1] + a[i];</code></li>
<li><code>dp[i][1][0] = max(&#123;dp[i - 1][1][0], dp[i - 1][1][1], -dp[i - 1][0][0], -dp[i - 1][0][1]&#125;) + a[i];</code> 分为前i-1没用过反转，前i-1用了反转</li>
<li><code>dp[i][1][1] = min(&#123;dp[i - 1][1][0], dp[i - 1][1][1], -dp[i - 1][0][0], -dp[i - 1][0][1]&#125;) + a[i];</code></li>
</ul>
</li>
<li>初始化：<ul>
<li><code>dp[i][0][0] = dp[i - 1][0][0] + a[i];</code></li>
<li><code>dp[i][0][1] = dp[i - 1][0][1] + a[i];</code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[N][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = a[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = -a[<span class="number">0</span>];</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="built_in">abs</span>(a[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        <span class="comment">// 不反转</span></span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] + a[i];</span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] + a[i];</span><br><span class="line">        <span class="comment">// 反转</span></span><br><span class="line">        dp[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(&#123;dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], -dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>], -dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]&#125;) + a[i];</span><br><span class="line">        dp[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">min</span>(&#123;dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], -dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>], -dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]&#125;) + a[i];</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(&#123;<span class="built_in">abs</span>(dp[i][<span class="number">0</span>][<span class="number">0</span>]), <span class="built_in">abs</span>(dp[i][<span class="number">0</span>][<span class="number">1</span>]), <span class="built_in">abs</span>(dp[i][<span class="number">1</span>][<span class="number">0</span>]), <span class="built_in">abs</span>(dp[i][<span class="number">1</span>][<span class="number">1</span>])&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="20250311-3-爱读书"><a href="#20250311-3-爱读书" class="headerlink" title="20250311_3_爱读书"></a>20250311_3_爱读书</h2><p>动态规划</p>
<ul>
<li>定义状态<ul>
<li><code>dp[i][j]</code>：读到第i页，用了j分钟学到的最大知识量</li>
</ul>
</li>
<li>状态转移方程：<ul>
<li>一分钟读一页：<code>dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + a[i]);</code></li>
<li>一分钟读两页：<code>dp[i][j] = max(dp[i][j], dp[i - 2][j - 1] + (a[i] + a[i - 1]) / 2.0);</code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">double</span> dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span>(m * <span class="number">2</span> &lt; n) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ ) &#123;</span><br><span class="line">            <span class="comment">// 用一分钟读第i页</span></span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i]);</span><br><span class="line">            <span class="comment">// 用一分钟读两页</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">2</span>][j - <span class="number">1</span>] + (a[i] + a[i - <span class="number">1</span>]) / <span class="number">2.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> ans = dp[n][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[n][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1f\n&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔试题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot项目运行显示端口占用问题</title>
    <url>/2024/05/19/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/SpringBoot%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E6%98%BE%E7%A4%BA%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>记录一个怪问题</p>
<span id="more"></span>

<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Web server failed to start. Port 8080 was already <span class="keyword">in</span> use.</span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Identify and stop the process that<span class="string">&#x27;s listening on port 8080 or configure this application to listen on another port.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Process finished with exit code 0</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>查询端口信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -ano | findstr :8080</span><br><span class="line"> TCP    10.149.0.108:5640      49.7.253.65:8080       ESTABLISHED     27564</span><br></pre></td></tr></table></figure>

<p>杀死端口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">taskkill /pid 27564 /f</span><br></pre></td></tr></table></figure>

<p>但杀死的端口时qq的，8080端口没有占用后，程序还是报同样的错误</p>
<p>配置文件中换成8081端口后，不报错，但关闭IDEA，又打开后，运行程序显示8081端口被占用。</p>
<p>没找到解决办法，最后重启解决。。。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring容器和注解</title>
    <url>/2024/05/08/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/newcoder%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86Spring%E5%AE%B9%E5%99%A8%E5%92%8C%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>官方文档<a href="https://springdoc.cn/spring/core.htm">https://springdoc.cn/spring/core.htm</a></p>
<span id="more"></span>

<h2 id="Bean和容器"><a href="#Bean和容器" class="headerlink" title="Bean和容器"></a>Bean和容器</h2><p>在spring中，构成程序的骨干和被容器管理的对象称为Bean。</p>
<p><code>org.springframework.context.ApplicationContext</code> 接口代表Spring IoC容器，负责实例化、配置和组装bean。</p>
<p>容器获取Bean的方式有</p>
<ul>
<li>通过类型获取<code>AlphaDao alphaDao = applicationContext.getBean(AlphaDao.class);</code></li>
<li>通过名字获取<code>AlphaDao alphaDao = (AlphaDao) applicationContext.getBean(&quot;alphaHibernate&quot;);</code></li>
</ul>
<p>可以通过<code>XML</code>和注解将Bean实例初始化到容器中。</p>
<h3 id="Primary-注解"><a href="#Primary-注解" class="headerlink" title="@Primary 注解"></a><code>@Primary</code> 注解</h3><p><code>@Primary</code> 表示，当多个Bean是自动注入到一个单值（single value）依赖的候选者时，应该优先考虑一个特定的Bean。如果在候选者中正好有一个主要（primary）Bean存在，它就会成为自动注入的值。</p>
<h3 id="和生命周期有关的注解"><a href="#和生命周期有关的注解" class="headerlink" title="和生命周期有关的注解"></a>和生命周期有关的注解</h3><p><code>@PostConstruct</code> 在构造函数调用后执行</p>
<p><code> @PreDestroy</code>  在销毁前执行</p>
<h3 id="Scope注解"><a href="#Scope注解" class="headerlink" title="@Scope注解"></a><code>@Scope</code>注解</h3><ul>
<li>能够管理Bean的作用域</li>
<li>默认情况下是单例  <code>@Scope(&quot;singleton&quot;)</code></li>
<li>可以变为任何数量的实例  <code>@Scope(&quot;prototype&quot;)</code></li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBeanManage</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">AlphaService</span> <span class="variable">alphaService</span> <span class="operator">=</span> applicationContext.getBean(AlphaService.class);</span><br><span class="line">	System.out.println(alphaService);</span><br><span class="line"></span><br><span class="line">	alphaService = applicationContext.getBean(AlphaService.class);</span><br><span class="line">	System.out.println(alphaService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Configuration注解"><a href="#Configuration注解" class="headerlink" title="@Configuration注解"></a><code>@Configuration</code>注解</h3><p>被<code>@Configuration</code>标记的类中的<code>@Bean</code>的方法会被Spring容器统一管理</p>
<h3 id="Autowired注解"><a href="#Autowired注解" class="headerlink" title="@Autowired注解"></a><code>@Autowired</code>注解</h3><p>手动获取<code>Bean</code>的方式，用<code>ApplicationContext</code></p>
<p>使用<code>@Autowired</code>可以自动注入<code>bean</code></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AlphaDao alphaDao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AlphaService alphaService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SimpleDateFormat simpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDI</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(alphaDao);</span><br><span class="line">    System.out.println(alphaService);</span><br><span class="line">    System.out.println(simpleDateFormat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Qualifier注解"><a href="#Qualifier注解" class="headerlink" title="@Qualifier注解"></a><code>@Qualifier</code>注解</h3><p>缩小注入<code>Bean</code>的类型匹配的范围</p>
<h3 id="RequestMapping注解"><a href="#RequestMapping注解" class="headerlink" title="@RequestMapping注解"></a><code>@RequestMapping</code>注解</h3><p>用于映射HTTP请求方式</p>
<ol>
<li><p><code>Get</code>请求获取参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只有GET方法能请求到</span></span><br><span class="line">   <span class="comment">// /students?current=1&amp;limit=20</span></span><br><span class="line">   <span class="meta">@RequestMapping(value = &quot;/students&quot;, method = RequestMethod.GET)</span></span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getStudents</span><span class="params">(</span></span><br><span class="line"><span class="params">           <span class="meta">@RequestParam(name = &quot;current&quot;, required = false, defaultValue = &quot;1&quot;)</span> <span class="type">int</span> current,</span></span><br><span class="line"><span class="params">           <span class="meta">@RequestParam(name = &quot;limit&quot;, required = false, defaultValue = &quot;10&quot;)</span> <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">       System.out.println(current);</span><br><span class="line">       System.out.println(limit);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;some students&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// /student/123, 获取参数的方式</span></span><br><span class="line">   <span class="meta">@RequestMapping(value = &quot;/student/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getStudent</span><span class="params">(<span class="meta">@PathVariable(name = &quot;id&quot;)</span><span class="type">int</span> id)</span> &#123;</span><br><span class="line">       System.out.println(id);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;a student&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>Post</code>请求获取参数</p>
<p>场景：路径的长度是有限的，无法在路径中获取很多的参数，因此使用<code>POST</code>请求接收数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// POST请求</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/student&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">saveStudent</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    System.out.println(age);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="ResponseBody注解"><a href="#ResponseBody注解" class="headerlink" title="@ResponseBody注解"></a><code>@ResponseBody</code>注解</h3><p>将方法的返回值直接作为HTTP响应的内容返回</p>
<p>不加这个注解，默认返回<code>HTML</code>数据</p>
<h3 id="RequestParam注解"><a href="#RequestParam注解" class="headerlink" title="@RequestParam注解"></a><code>@RequestParam</code>注解</h3><p>用于获取 HTTP 请求中的请求参数，从请求的查询参数中获取参数值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/students&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getStudents</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(name = &quot;current&quot;, required = false, defaultValue = &quot;1&quot;)</span> <span class="type">int</span> current,</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(name = &quot;limit&quot;, required = false, defaultValue = &quot;1&quot;)</span> <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;some students&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<code>request</code>中名为<code>current</code>的参数赋值给函数中的<code>current</code>参数，<code>required = false</code>表示<code>request</code>中可以没有这个参数，<code>defaultValue</code>表示请求中没有这个参数时默认值为1。</p>
<h3 id="PathVariable注解"><a href="#PathVariable注解" class="headerlink" title="@PathVariable注解"></a><code>@PathVariable</code>注解</h3><p>用于获取 URL 中的路径变量的值，从请求的URL路径中获取参数值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /student/123, 获取参数的方式</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/student/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getStudent</span><span class="params">(<span class="meta">@PathVariable(name = &quot;id&quot;)</span><span class="type">int</span> id)</span> &#123;</span><br><span class="line">    System.out.println(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;a student&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Component-注解"><a href="#Component-注解" class="headerlink" title="@Component 注解"></a><code>@Component</code> 注解</h3><p><code>@Component</code> 注解应用于类上，以指示该类是一个spring所管理的组件。</p>
<h3 id="Value-注解"><a href="#Value-注解" class="headerlink" title="@Value 注解"></a><code>@Value</code> 注解</h3><p><code>@Value</code> 注解用于将配置属性的值注入到Spring管理的Bean的字段中</p>
<h3 id="Options注解"><a href="#Options注解" class="headerlink" title="@Options注解"></a><code>@Options</code>注解</h3><p>数据库相关配置</p>
<p><code>@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)</code>：表示主键自生成</p>
<h2 id="Java项目中的三层"><a href="#Java项目中的三层" class="headerlink" title="Java项目中的三层"></a>Java项目中的三层</h2><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a><code>Controller</code></h3><p>”业务控制层“</p>
<p>处理浏览器的请求，调用业务组件<code>Service</code></p>
<p>控制器层负责处理客户端发起的HTTP请求，并将请求转发给业务逻辑处理层（Service层）进行处理。</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a><code>Service</code></h3><p>”业务服务层“</p>
<p>业务逻辑层通常包含一组Service类，每个Service类对应系统中的一个业务模块，负责实现该模块的具体业务逻辑。</p>
<h3 id="Dao"><a href="#Dao" class="headerlink" title="Dao"></a><code>Dao</code></h3><p>”数据库持久层“</p>
<p>数据访问层负责与数据库进行交互，执行数据库操作（增删改查），并将数据传递给业务逻辑层进行处理。</p>
<h2 id="Spring中的常用配置"><a href="#Spring中的常用配置" class="headerlink" title="Spring中的常用配置"></a>Spring中的常用配置</h2><p>查找：<a href="https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/reference/htmlsingle/#common-application-properties">Spring Boot Reference Guide</a></p>
<p>将需要的配置写入<code>application.properties</code>中</p>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>newcoder项目前置知识之Mybatis</title>
    <url>/2024/05/10/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/newcoder%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E4%B9%8BMybatis/</url>
    <content><![CDATA[<p>官方文档<a href="https://mybatis.org/spring/">mybatis-spring</a></p>
<span id="more"></span>

<h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><p>负责创建SqlSession对象</p>
<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><p>用于与数据库进行交互。它提供了各种方法来执行SQL语句、获取Mapper接口的实例以及管理事务</p>
<h3 id="XML配置文件"><a href="#XML配置文件" class="headerlink" title="XML配置文件"></a>XML配置文件</h3><p><code>mybatis</code>底层配置</p>
<p> <code>application.properties</code>配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DataSourceProperties，统一管理连接，反复使用，管理连接池</span></span><br><span class="line"><span class="comment"># 数据库驱动</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment"># 数据库地址</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/community?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=HongKong</span></span><br><span class="line"><span class="comment"># 数据库用户名</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="comment"># 连接池</span></span><br><span class="line"><span class="attr">spring.datasource.type</span>=<span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line"><span class="comment"># 连接池最大连接数</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.maximum-pool-size</span>=<span class="string">15</span></span><br><span class="line"><span class="comment"># 连接池最小空闲连接</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.minimum-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># 连接池等多久把空闲的关掉</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.idle-timeout</span>=<span class="string">30000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># MybatisProperties</span></span><br><span class="line"><span class="comment"># 映射文件存放位置</span></span><br><span class="line"><span class="attr">mybatis.mapper-locations</span>=<span class="string">classpath:mapper/*.xml</span></span><br><span class="line"><span class="comment"># 实体类所在包名，封装某个表的数据</span></span><br><span class="line"><span class="attr">mybatis.type-aliases-package</span>=<span class="string">com.newcoder.community.entity</span></span><br><span class="line"><span class="comment"># 启动id自增长</span></span><br><span class="line"><span class="attr">mybatis.configuration.use-generated-keys</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 表的字段不区分大小写，属性名是驼峰命令，这个属性让表的字段和属性相匹配</span></span><br><span class="line"><span class="attr">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>



<h3 id="Mapper接口"><a href="#Mapper接口" class="headerlink" title="Mapper接口"></a>Mapper接口</h3><p>定义数据访问操作的接口，通常对应于数据库中的一个表或一个实体</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    User <span class="title function_">selectId</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    User <span class="title function_">selectByName</span><span class="params">(String username)</span>;</span><br><span class="line">    User <span class="title function_">selectByEmail</span><span class="params">(String email)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertUser</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateStatus</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> status)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateHeader</span><span class="params">(<span class="type">int</span> id, String headUrl)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">updatePassword</span><span class="params">(<span class="type">int</span> id, String password)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Mapper映射器"><a href="#Mapper映射器" class="headerlink" title="Mapper映射器"></a>Mapper映射器</h3><p>用于将Mapper接口中的方法与对应的SQL语句进行映射，可以用XML也可以用注解写。</p>
<p>对<code>UserMapper</code>中每一个方法都要写一个标签对应，很容易写错</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.newcoder.community.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;selectField&quot;</span>&gt;</span></span><br><span class="line">        id, username, password, salt, email, type, status, activation_code, header_url, create_time</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;insertFile&quot;</span>&gt;</span></span><br><span class="line">        username, password, salt, email, type, status, activation_code, header_url, create_time</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectField&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        from user</span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectField&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        from user</span><br><span class="line">        where username = #&#123;username&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByEmail&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectField&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        from user</span><br><span class="line">        where email = #&#123;email&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>  <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        insert into user (<span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;insertFile&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>)</span><br><span class="line">        value (#&#123;username&#125;, #&#123;password&#125;, #&#123;salt&#125;, #&#123;email&#125;, #&#123;type&#125;, #&#123;status&#125;, #&#123;activationCode&#125;, #&#123;headerUrl&#125;,</span><br><span class="line">        #&#123;createTime&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateStatus&quot;</span>&gt;</span></span><br><span class="line">        update user set status = #&#123;status&#125; where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateHeader&quot;</span>&gt;</span></span><br><span class="line">        update user set header_url = #&#123;headerUrl&#125; where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updatePassword&quot;</span>&gt;</span></span><br><span class="line">        update user set password = #&#123;password&#125; where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByName&quot;</span>&gt;</span></span><br><span class="line">        delete</span><br><span class="line">        from user</span><br><span class="line">        where username = #&#123;username&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Mybatis的注解"><a href="#Mybatis的注解" class="headerlink" title="Mybatis的注解"></a><code>Mybatis</code>的注解</h2><h3 id="Param注解"><a href="#Param注解" class="headerlink" title="@Param注解"></a><code>@Param</code>注解</h3><p>用于解决方法参数与SQL语句中的参数对应关系不明确的情况，给参数名起别名</p>
<p><code>XML</code>文件中使用动态SQL，要拼接SQL语句时，参数中一定要用<code>@Param</code>注解</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="1-连不上数据库"><a href="#1-连不上数据库" class="headerlink" title="1. 连不上数据库"></a>1. 连不上数据库</h3><p>报错:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException: </span><br><span class="line"><span class="comment">### Error querying database.  Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is java.sql.SQLException: Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27; (using password: YES)</span></span><br><span class="line"><span class="comment">### The error may exist in file [D:\learning\projects\newcoder\community\target\classes\mapper\user-mapper.xml]</span></span><br><span class="line"><span class="comment">### The error may involve com.newcoder.community.dao.UserMapper.selectById</span></span><br><span class="line"><span class="comment">### The error occurred while executing a query</span></span><br><span class="line"><span class="comment">### Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is java.sql.SQLException: Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27; (using password: YES)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可能的原因：</p>
<ol>
<li>用户名，密码写错</li>
<li>查询数据库的语句写错</li>
<li>数据库的连接地址不对</li>
</ol>
<p>我的问题是，查询语句中的属性名写错了。</p>
<p>在mapper文件中表名爆红，不会报错。</p>
<p>为了便于调试可以把日志级别在配置里改为<code>debug</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># logger</span></span><br><span class="line"><span class="attr">logging.level.com.newcoder.community</span>=<span class="string">debug</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>newcoder项目前置知识之SpringMVC</title>
    <url>/2024/05/08/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/newcoder%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E4%B9%8BSpringMVC/</url>
    <content><![CDATA[<p>官方文档：<a href="https://springdoc.cn/spring/web.html#mvc">Servlet 栈的 Web 应用 (springdoc.cn)</a></p>
<span id="more"></span>

<h2 id="SpringMVC三层架构"><a href="#SpringMVC三层架构" class="headerlink" title="SpringMVC三层架构"></a>SpringMVC三层架构</h2><p><code>Spring</code>是分为三层：表现层、业务层、数据层</p>
<p><code>SpringMVC</code>：服务于表现层，将表现层分为<code>controller</code>（控制层）、<code>model</code>（模型层）、<code>view</code>（视图层）</p>
<p>model层已有，需要自己写的是<code>controller</code>和模板引擎（<code>thymeleaf</code>）</p>
<h2 id="请求响应数据"><a href="#请求响应数据" class="headerlink" title="请求响应数据"></a>请求响应数据</h2><h3 id="1-响应String类型数据"><a href="#1-响应String类型数据" class="headerlink" title="1.响应String类型数据"></a>1.响应String类型数据</h3><p>将方法的返回值直接作为HTTP响应的内容返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只有GET方法能请求到</span></span><br><span class="line"><span class="comment">// /students?current=1&amp;limit=20</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/students&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getStudents</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(name = &quot;current&quot;, required = false, defaultValue = &quot;1&quot;)</span> <span class="type">int</span> current,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(name = &quot;limit&quot;, required = false, defaultValue = &quot;10&quot;)</span> <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">    System.out.println(current);</span><br><span class="line">    System.out.println(limit);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;some students&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /student/123, 获取参数的方式</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/student/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getStudent</span><span class="params">(<span class="meta">@PathVariable(name = &quot;id&quot;)</span><span class="type">int</span> id)</span> &#123;</span><br><span class="line">    System.out.println(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;a student&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// POST请求</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/student&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">saveStudent</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    System.out.println(age);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-响应HTML数据"><a href="#2-响应HTML数据" class="headerlink" title="2. 响应HTML数据"></a>2. 响应HTML数据</h3><p>SpringMVC会根据视图解析器将逻辑视图名称解析成实际的视图文件路径，然后将模型中的数据渲染到该视图文件中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 响应HTML数据</span></span><br><span class="line">   <span class="meta">@RequestMapping(value = &quot;/teacher&quot;, method = RequestMethod.GET)</span></span><br><span class="line">   <span class="keyword">public</span> ModelAndView <span class="title function_">getTeacher</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">       mav.addObject(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;gxy&quot;</span>);</span><br><span class="line">       mav.addObject(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;22&quot;</span>);</span><br><span class="line">       mav.setViewName(<span class="string">&quot;/demo/view&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> mav;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 更为简洁的方法</span></span><br><span class="line">   <span class="meta">@RequestMapping(value = &quot;/school&quot;, method = RequestMethod.GET)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getSchool</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">       model.addAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;ouc&quot;</span>);</span><br><span class="line">       model.addAttribute(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;99&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;/demo/view&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>视图文件使用<code>thymeleaf</code>模板引擎，用于在HTML页面上生成动态数据</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Teacher<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;age&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="3-响应JSON数据"><a href="#3-响应JSON数据" class="headerlink" title="3. 响应JSON数据"></a>3. 响应JSON数据</h3><p>一般用于异步请求中，异步请求通俗说就是不刷新页面，但访问了服务器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相应JSON数据（一般在异步请求中）</span></span><br><span class="line"><span class="comment">// 通过JSON字符串，JAVA对象可以转成JS对象</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/emp&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">getEmp</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; emp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    emp.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;gxy&quot;</span>);</span><br><span class="line">    emp.put(<span class="string">&quot;age&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    emp.put(<span class="string">&quot;salary&quot;</span>, <span class="string">&quot;15k&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> emp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/emps&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">getEmps</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Map&lt;String, Object&gt; emp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    emp.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;gxy&quot;</span>);</span><br><span class="line">    emp.put(<span class="string">&quot;age&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    emp.put(<span class="string">&quot;salary&quot;</span>, <span class="string">&quot;15k&quot;</span>);</span><br><span class="line">    list.add(emp);</span><br><span class="line"></span><br><span class="line">    emp.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hyy&quot;</span>);</span><br><span class="line">    emp.put(<span class="string">&quot;age&quot;</span>, <span class="number">19</span>);</span><br><span class="line">    emp.put(<span class="string">&quot;salary&quot;</span>, <span class="string">&quot;15k&quot;</span>);</span><br><span class="line">    list.add(emp);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-响应图片数据"><a href="#4-响应图片数据" class="headerlink" title="4. 响应图片数据"></a>4. 响应图片数据</h3><p>返回一个图片，示例为响应验证码图片</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/kaptcha&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getKaptcha</span><span class="params">(HttpServletResponse response, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> kaptchaProducer.createText();</span><br><span class="line">    <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> kaptchaProducer.createImage(text);</span><br><span class="line">    <span class="comment">// 将验证码返回给session</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;kaptcha&quot;</span>, text);</span><br><span class="line">    <span class="comment">// 设置响应类型</span></span><br><span class="line">    response.setContentType(<span class="string">&quot;image/png&quot;</span>);</span><br><span class="line">    <span class="comment">// 将图片输出给浏览器(将生成的图片写入响应数据流)</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        ImageIO.write(image, <span class="string">&quot;png&quot;</span>, os);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;响应验证码失败&quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>仿牛客论坛项目01-首页功能</title>
    <url>/2025/03/04/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE01-%E9%A6%96%E9%A1%B5%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>仿牛客论坛项目01-首页功能，内容记录</p>
<span id="more"></span>

<h2 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h2><p>代码写的顺序：<code>Dao</code>-&gt;<code>Service</code>-&gt;<code>Controller</code></p>
<h3 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a><code>DAO</code></h3><p>方法1：需要查询所有的帖子，查询所有的不需要参数；考虑到之后还有功能个人主页上显示自己的博客，因此，方法中要加上<code>userID</code>参数；还有分页功能，方法中还要加上页数的索引<code>offset</code>，以及每页的限制<code>limit</code>。</p>
<p>方法2：为了实现分页功能，需要查询所有帖子的行数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DiscussPostMapper</span> &#123;</span><br><span class="line">    List&lt;DiscussPost&gt; <span class="title function_">selectDiscussPosts</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> offset, <span class="type">int</span> limit)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">selectDiscussPostsRows</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> <span class="type">int</span> userId)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对应的配置文件：</p>
<p>不选择拉黑的帖子，拼接动态SQL</p>
<p>首先按是否置顶排序，再按创建时间降序排序，最近发布的在上面</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;selectField&quot;</span>&gt;</span></span><br><span class="line">       id, user_id, title, content, type, status, create_time, comment_count, score</span><br><span class="line">   <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectDiscussPosts&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;DiscussPost&quot;</span>&gt;</span></span><br><span class="line">       select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectField&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">       from discuss_post</span><br><span class="line">       where status != 2</span><br><span class="line">       <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userId != 0&quot;</span>&gt;</span></span><br><span class="line">           and user_id = #&#123;userId&#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       order by type desc, create_time desc</span><br><span class="line">       limit #&#123;offset&#125;, #&#123;limit&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectDiscussPostsRows&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">       select count(id)</span><br><span class="line">       from discuss_post</span><br><span class="line">       where status != 2</span><br><span class="line">       <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userId != 0&quot;</span>&gt;</span></span><br><span class="line">           and user_id = #&#123;userId&#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p><code>DiscussPostService</code>调用<code>Dao</code>层中的方法，并将获取到的数据通过<code>userId</code>和<code>username</code>一起返回，因此还需要一个<code>UserService</code></p>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>静态资源、页面导入</p>
<p>在该层中调用<code>Service</code>，返回模板的路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/index&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getIndexPage</span><span class="params">(Model model, Page page)</span> &#123;</span><br><span class="line">    <span class="comment">// SpringMVC会将Page自动注入到Model，并将请求中的查询参数映射到这个对象上</span></span><br><span class="line">    <span class="comment">// 这样Thymeleaf可以直接使用Page中的数据</span></span><br><span class="line">    <span class="comment">// 服务端可以设置的分页参数</span></span><br><span class="line">    page.setRows(discussPostService.findDiscussPostsRows(<span class="number">0</span>));</span><br><span class="line">    page.setPath(<span class="string">&quot;/index&quot;</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;DiscussPost&gt; list = discussPostService.findDiscussPosts(<span class="number">0</span>, page.getOffset(), page.getLimit());</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; postList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(list != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(DiscussPost post : list) &#123;</span><br><span class="line">            <span class="comment">// 将用户名加入列表中</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(post.getUserId());</span><br><span class="line">            Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">&quot;post&quot;</span>, post);</span><br><span class="line">            map.put(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">            postList.add(map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;discussPosts&quot;</span>, postList);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分页功能"><a href="#分页功能" class="headerlink" title="分页功能"></a>分页功能</h2><p><strong>分页类需要用到的参数：</strong></p>
<ol>
<li><code>current</code> 为当前页码</li>
<li><code>limit</code> 为每页上限</li>
<li><code>rows</code> 为数据总数</li>
<li><code>path</code> 为查询路径（封装在里面，查询时就不用字符串拼接了）</li>
</ol>
<p>上述参数有限制条件可以在<code>setter</code>中写，比如当前页数不能为负数。</p>
<p><strong>分页类需要用到的方法：</strong></p>
<ol>
<li><code>getOffset</code> 获取当前页的起始行，在数据库查询时需要用到</li>
<li><code>getTotal</code> 获取总页码，页面上显示的页码不能超过总页码</li>
<li><code>getFrom</code>  当页码还要显示前后几个页码，获取这段页码的起始页码</li>
<li><code>getTo</code> 获取这段页码的结束页码</li>
</ol>
<p><code>index</code>页面中分页实现逻辑：</p>
<ol>
<li>没有数据时不需要分页</li>
<li>用遍历显示当前页码，和前两个到后两个的页码</li>
<li>当前页的按钮状态为激活</li>
<li>处于第一页时，上一页禁用</li>
<li>处于最后一页时，下一页禁用</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 分页 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;mt-5&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;page.rows&gt;0&#125;&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;pagination justify-content-center&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- /index?current=1 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;page-item&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;page-link&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;$&#123;page.path&#125;(current=1)&#125;&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span> <span class="attr">th:class</span>=<span class="string">&quot;|page-item $&#123;page.current==1?&#x27;disabled&#x27;:&#x27;&#x27;&#125;|&quot;</span> &gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;page-link&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;$&#123;page.path&#125;(current=$&#123;page.current-1&#125;)&#125;&quot;</span>&gt;</span>上一页</span><br><span class="line">			    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span> <span class="attr">th:class</span>=<span class="string">&quot;|page-item $&#123;i==page.current?&#x27;active&#x27;:&#x27;&#x27;&#125;|&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">th:each</span>=<span class="string">&quot;i:$&#123;#numbers.sequence(page.from, page.to)&#125;&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;page-link&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;$&#123;page.path&#125;(current=$&#123;i&#125;)&#125;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;i&#125;&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span> <span class="attr">th:class</span>=<span class="string">&quot;|page-item $&#123;page.current==page.total?&#x27;disabled&#x27;:&#x27;&#x27;&#125;|&quot;</span> &gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;page-link&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;$&#123;page.path&#125;(current=$&#123;page.current+1&#125;)&#125;&quot;</span>&gt;</span>下一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;page-item&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;page-link&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;$&#123;page.path&#125;(current=$&#123;page.total&#125;)&#125;&quot;</span>&gt;</span>末页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="Thymeleaf语法"><a href="#Thymeleaf语法" class="headerlink" title="Thymeleaf语法"></a>Thymeleaf语法</h2><p><strong><code>thymeleaf</code>作用</strong>：前端页面中使用Thymeleaf表达式来访问<code>Model</code>中的数据</p>
<p>导入<code>thymeleaf</code>：<code>&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</code></p>
<p>页面中导入的静态资源有相对路径时，需要使用<code>thymeleaf</code>语法</p>
<p><code>&lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;css/global.css&#125;&quot; /&gt;</code> 这样写默认去<code>static</code>下寻找</p>
<p>循环：<code>th:each=&quot;map:$&#123;discussPosts&#125;&quot;</code> map是遍历时的元素</p>
<p>内容：<code>th:utext=&quot;$&#123;map.post.title&#125;&quot;</code>  <code>utext</code>可以解析转义字符</p>
<p>判断：<code>th:if=&quot;$&#123;map.post.type==1&#125;&quot;</code></p>
<p>时间格式化：<code>th:text=&quot;$&#123;#dates.format(map.post.createTime, &#39;yyyy-MM-dd HH:mm:ss&#39;)&#125;&quot;</code></p>
<h3 id="Thymeleaf符号"><a href="#Thymeleaf符号" class="headerlink" title="Thymeleaf符号"></a><code>Thymeleaf</code>符号</h3><ol>
<li><p><code>#</code> ：标识Thymeleaf内置的标准表达式对象，如<code>#dates</code>用于日期操作</p>
</li>
<li><p><code>$</code> ：用于获取变量的值，并将其插入到模板中，如<code>post.title</code></p>
</li>
<li><p><code>@</code> ：用于表示Thymeleaf中的URL表达式</p>
</li>
<li><p><code>|</code> ：可以将一个静态的字符串和一个表达式拼接在一起</p>
<p><code>&lt;li th:class=&quot;|page-item $&#123;page.current==page.total?&#39;disabled&#39;:&#39;&#39;&#125;|&quot; &gt;</code></p>
</li>
<li><p><code>th:text</code> ：用于设置标签内文本的值</p>
</li>
<li><p><code>th:if</code> ：用于条件判断，根据条件的真假来显示或隐藏标签</p>
</li>
<li><p><code>th:each</code>：用于遍历集合或数组，将集合中的每个元素逐个处理</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:each</span>=<span class="string">&quot;item : $&#123;items&#125;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;item&#125;&quot;</span>&gt;</span>Item<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>th:href</code>：用于设置链接的URL</p>
</li>
<li><p>&#96;&#96;th:class&#96;：用于设置标签的类名</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:class</span>=<span class="string">&quot;$&#123;condition&#125; ? &#x27;class1&#x27; : &#x27;class2&#x27;&quot;</span>&gt;</span>Content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">th:class</span>=<span class="string">&quot;|page-item $&#123;page.current==page.total?&#x27;disabled&#x27;:&#x27;&#x27;&#125;|&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>th:fragment</code>：用于定义一个可重用的模板片段，可以在其他模板被引入并重用</p>
</li>
<li><p><code>th:replace</code>：用于在一个模板中引入另一个模板，替换该标签的内容</p>
<p><code>&lt;div th:replace=&quot;fragments :: myFragment&quot;&gt;&lt;/div&gt;</code>表示</p>
</li>
</ol>
<h3 id="Content"><a href="#Content" class="headerlink" title="Content"></a><code>Content</code></h3><p>在Thymeleaf中，<code>context</code>类主要用于传递变量和数据模型到模板引擎，以便在HTML模板中进行数据渲染。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p>在page类里没有配置total属性，但是有一个getTotal方法，controller类里将page注入给了model，为什么在thymeleaf中可以直接使用page.total，而不用getTotal</p>
<p>尽管<code>Page</code>类没有直接定义一个名为<code>total</code>的属性，但是存在一个<code>getTotal()</code>方法。根据JavaBean的命名规则，Thymeleaf会认为<code>getTotal()</code>方法是用来获取<code>total</code>属性的值的。因此，Thymeleaf允许直接使用<code>page.total</code>来访问这个属性的值，而不需要显式调用<code>getTotal()</code>方法。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java项目</category>
      </categories>
      <tags>
        <tag>Java SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>仿牛客论坛项目02-注册激活功能</title>
    <url>/2025/03/05/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE02-%E6%B3%A8%E5%86%8C%E6%BF%80%E6%B4%BB%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>仿牛客论坛项目02-注册激活功能，内容记录</p>
<span id="more"></span>

<h2 id="发送邮件功能"><a href="#发送邮件功能" class="headerlink" title="发送邮件功能"></a>发送邮件功能</h2><h3 id="导入邮件jar包"><a href="#导入邮件jar包" class="headerlink" title="导入邮件jar包"></a>导入邮件jar包</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置邮箱参数"><a href="#配置邮箱参数" class="headerlink" title="配置邮箱参数"></a>配置邮箱参数</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#MailProperties</span></span><br><span class="line"><span class="attr">spring.mail.host</span>=<span class="string">smtp.sina.com</span></span><br><span class="line"><span class="attr">spring.mail.port</span>=<span class="string">465</span></span><br><span class="line"><span class="attr">spring.mail.username</span>=<span class="string">newcodergxy@sina.com</span></span><br><span class="line"><span class="comment"># 邮箱授权码</span></span><br><span class="line"><span class="attr">spring.mail.password</span>=<span class="string">xxx</span></span><br><span class="line"><span class="attr">spring.mail.protocol</span>=<span class="string">smtp</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.ssl.enable</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<h3 id="使用JavaMailSender"><a href="#使用JavaMailSender" class="headerlink" title="使用JavaMailSender"></a>使用JavaMailSender</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMail</span><span class="params">(String to, String subject, String content)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">MimeMessage</span> <span class="variable">message</span> <span class="operator">=</span> mailSender.createMimeMessage();</span><br><span class="line">        <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(message);</span><br><span class="line">        helper.setFrom(from);</span><br><span class="line">        helper.setTo(to);</span><br><span class="line">        helper.setSubject(subject);</span><br><span class="line">        helper.setText(content, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        mailSender.send(helper.getMimeMessage());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;发送邮件失败：&quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="注册功能"><a href="#注册功能" class="headerlink" title="注册功能"></a>注册功能</h2><p>写功能时，可以将功能按照在浏览器中的请求，进行拆解</p>
<p>注册功能有三次请求：</p>
<ol>
<li>访问注册页面</li>
<li>提交注册信息<ul>
<li>通过表单提交数据</li>
<li>服务端验证账号是否注册过</li>
<li>服务端发送激活邮件</li>
</ul>
</li>
<li>激活注册账号<ul>
<li>点击邮件中的链接，访问服务器中的激活服务</li>
</ul>
</li>
</ol>
<p>当用户在前端页面上点击注册时，前后端会发生什么：</p>
<ol>
<li>用户点击注册按钮，浏览器发送GET请求到<code>/register</code>。</li>
<li>Spring MVC的<code>DispatcherServlet</code>接收请求，并找到对应的Controller方法。</li>
<li>Controller方法返回视图名，视图解析器解析视图并渲染<code>register.html</code>页面。</li>
<li>浏览器显示<code>register.html</code>页面，用户填写表单并提交。</li>
<li>浏览器发送POST请求到<code>/register</code>，包含用户的注册信息。</li>
<li>Controller处理POST请求，保存用户信息，并返回响应。</li>
</ol>
<h3 id="访问注册页面"><a href="#访问注册页面" class="headerlink" title="访问注册页面"></a>访问注册页面</h3><p>该功能不需要<code>Service</code>层和<code>Dao</code>层，写<code>controller</code>层，前端从<code>index</code>页面点击头部的注册跳转到注册页面</p>
<p><code>Controller</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/register&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getRegisterPage</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;/site/register&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前端标签复用：在<code>index</code>页面中修改头部注册的路径，并将index的头部模板复用，在注册页面中引入（<code>thymeleaf</code>语法）</p>
<h3 id="提交注册信息"><a href="#提交注册信息" class="headerlink" title="提交注册信息"></a>提交注册信息</h3><p><code>Service</code>层：写注册业务，包括：检查数据的合法性，设置<code>User</code>的其他属性，插入用户，发送激活邮件</p>
<p><code>Controller</code>层：调用<code>Service</code>层，需要接收注册的<code>POST</code>请求</p>
<p><code>operator-result.html</code>：操作后进行跳转，提示信息和跳转链接需要由<code>Controller</code>层传入</p>
<p><code>register.html</code>：修改表单，提交数据；注册失败时返回这个页面，页面上要有填入的注册信息以及失败提示。</p>
<h3 id="激活注册邮件"><a href="#激活注册邮件" class="headerlink" title="激活注册邮件"></a>激活注册邮件</h3><p>改变数据库中的用户状态</p>
<p><code>Service</code>层：实现激活逻辑，激活时会传给服务器，激活的用户和激活码。</p>
<p><code>Controller</code>层：调用<code>Service</code>层，激活成功后，给用户提示，并跳转到目标页面；当激活成功时，需要跳转到登陆页面，因此该层还需要写登录页面</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p>注册时在前端对属性进行校验了，为什么了在后端<code>Service</code>层还要校验？</p>
<p>前端校验容易被绕过。用户可以禁用JavaScript、使用浏览器开发者工具修改前端代码等直接向服务器发送请求。所有进入数据库的数据必须在后端经过严格的校验，以防止出现数据异常。</p>
</li>
<li><p>自我拷问：说说注册模块</p>
<ul>
<li>用户点击首页上的注册按钮，服务端响应注册页面</li>
<li>用户在注册页面上，需要填写账号、密码、邮箱，最后点击注册页面，服务端接收到该<code>Post</code>请求，验证账号、邮箱的合理性。</li>
<li>若账号邮箱为空或已注册过，返回相关错误信息，跳转到注册页面</li>
<li>若账号邮箱没有问题，将密码加上盐进行加密，存入数据库中，跳转到操作结果页面。</li>
<li>服务端发送激活邮件给用户，用户点击邮件后，服务端判断激活码是否正确，若正确将该用户状态设置为激活，跳转到登录页面。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java项目</category>
      </categories>
      <tags>
        <tag>Java SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>仿牛客论坛项目03-登录功能</title>
    <url>/2025/03/05/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE03-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>仿牛客论坛项目03-登录功能，内容记录。</p>
<p>会话管理，cookie，session，验证码，hostHolder，拦截器</p>
<span id="more"></span>

<h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/cookie/set&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">setCookie</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建cookie</span></span><br><span class="line">    <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;code&quot;</span>, CommunityUtil.generateUUID());</span><br><span class="line">    <span class="comment">// 设置cookie生效路径</span></span><br><span class="line">    cookie.setPath((<span class="string">&quot;/community/alpha&quot;</span>));</span><br><span class="line">    <span class="comment">// 设置cookie生效时间</span></span><br><span class="line">    cookie.setMaxAge(<span class="number">600</span>);</span><br><span class="line">    <span class="comment">// 将cookie放入response响应头中</span></span><br><span class="line">    response.addCookie(cookie);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;set cookie&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>请求映射</strong>：当一个GET请求发送到服务器的”&#x2F;cookie&#x2F;set”路径时，Spring框架会根据<code>@RequestMapping</code>注解找到这个<code>setCookie</code>方法来处理请求。</li>
<li><strong>创建Cookie</strong>：在<code>setCookie</code>方法内部，首先创建了一个<code>Cookie</code>对象。<code>CommunityUtil.generateUUID()</code>方法（这个类和方法没有在代码中定义，可能是自定义的）被用来生成一个唯一的标识符（UUID），作为Cookie的值。</li>
<li><strong>设置Cookie属性</strong>：<ul>
<li><code>cookie.setPath(&quot;/community/alpha&quot;)</code>：设置了Cookie的路径，这意味着Cookie只会在域名下的”&#x2F;community&#x2F;alpha”路径及其子路径中有效。</li>
<li><code>cookie.setMaxAge(600)</code>：设置了Cookie的最大年龄（以秒为单位）。在这个例子中，Cookie将在600秒（10分钟）后过期。</li>
</ul>
</li>
<li><strong>添加到响应</strong>：通过<code>response.addCookie(cookie)</code>方法，将创建的Cookie添加到HTTP响应中。这样，当响应发送回浏览器时，Cookie也会一起发送。</li>
<li><strong>响应体</strong>：函数返回了一个字符串”set cookie”，这将作为HTTP响应的响应体发送回客户端。客户端浏览器会显示这个字符串，但更重要的是，浏览器会存储下发的Cookie。</li>
<li><strong>客户端存储Cookie</strong>：浏览器接收到响应后，会根据响应头中的<code>Set-Cookie</code>指令存储Cookie。由于设置了路径，浏览器只会在访问指定路径时发送这个Cookie。</li>
<li><strong>浏览器显示结果</strong>：浏览器会向用户显示返回的字符串”set cookie”，表示Cookie设置操作已经完成。</li>
<li><strong>Cookie的使用</strong>：从这一刻起，只要用户在浏览器中访问了指定路径，浏览器就会自动携带这个Cookie。服务器可以通过检查请求中的Cookie来识别用户或会话。</li>
</ol>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>存在服务器中，比Cookie更安全，响应时通过Cookie将session的id传给服务器，浏览器下次请求时会带上session的id。</p>
<p>缺点是会增加服务端的压力。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/session/set&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">setSession</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">    session.setAttribute(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    session.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;set session&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题：若使用分布式服务器，中间件使用nginx负载均衡服务器，若浏览器发送了两次请求，第二次发送的请求，第二次请求的服务器上没有存这个session了</p>
<p><img src="/2025/03/05/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE03-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/2.png" alt="2"></p>
<p>解决方法：粘性session （固定的id传给同一个服务器处理，缺点是负载不均衡）、同步session（当一个服务器创建了一个session就会同步给别的服务器，缺点是同步影响服务器性能、服务器之间耦合影响部署）、共享session（单独一台服务器存储session，缺点是这台服务器崩溃后其他服务器也不能用了）</p>
<p><img src="/2025/03/05/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE03-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/3.png" alt="3"></p>
<p>主流方法：不存session了，尽量存cookie，敏感数据存在数据库（nosql数据库如Redis）中</p>
<h2 id="生成验证码"><a href="#生成验证码" class="headerlink" title="生成验证码"></a>生成验证码</h2><p>引入<code>Kaptcha</code>包用于生成验证码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.penggle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kaptcha<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>逻辑是：用户发送一个请求，服务端生成一个验证码，用session保存文本，将图片响应给浏览器。</p>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><h3 id="刷新验证码"><a href="#刷新验证码" class="headerlink" title="刷新验证码"></a>刷新验证码</h3><p>用JS写，因为用户刷新验证码不需要刷新整个页面，体验更好</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-sm-4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/kaptcha&#125;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:100px;height:40px;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;mr-2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:refresh_kaptcha();&quot;</span> <span class="attr">class</span>=<span class="string">&quot;font-size-12 align-bottom&quot;</span>&gt;</span>刷新验证码<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">    function refresh_kaptcha() &#123;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        <span class="comment">&lt;!-- 防止浏览器不更新链接 --&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        var path = CONTEXT_PATH + &quot;/kaptcha?p&quot; + Math.random();</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        <span class="comment">&lt;!-- id选择器获取更新验证码的标签 --&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        $(&quot;kaptcha&quot;).attr(&quot;src&quot;, path);</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">    &#125;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="登录、退出"><a href="#登录、退出" class="headerlink" title="登录、退出"></a>登录、退出</h3><p>实现逻辑：</p>
<ol>
<li>获取登录页面</li>
<li>验证账号、密码、验证码（成功，生成登录凭证给客户端，跳转到首页；失败，跳转到登录页面显示提示信息）</li>
<li>退出（登录凭证设置为失效，跳转到首页）</li>
</ol>
<p>生成登录凭证：</p>
<ul>
<li><p><code>Dao</code>层：</p>
<p>与<code>login_ticket</code>数据库交互，查询、增加、更新，写完后在<code>Test</code>类中进行测试</p>
</li>
<li><p><code>Service</code>层：</p>
<p>  用户登录不成功有多种情况，账号不存在、账号为激活、账号为空、密码为空、密码不正确</p>
<p>  登录成功后要把生成的<code>ticket</code>传给客户端</p>
</li>
<li><p><code>Controller</code>层：</p>
<p>  需要的参数有表单中提交的参数用户名、账号、验证码、是否记住账号，还需要Session从中获取生成的验证码。登录成功后要把登录凭证<code>ticket</code>传给cookie，因此还需要<code>HttpServletResponse</code>并将cookie保存到响应体<code>reponse</code>。</p>
<p>  判断是否勾选记住密码，选择对于的登录凭证超时时间。</p>
</li>
<li><p><code>login.html</code>页面：</p>
<ul>
<li>表单上需要有<code>name</code>属性，提交给服务器才能获取</li>
<li>账号密码不正确需要回到这个页面上还有账号密码信息，<code>th:value=&quot;$&#123;param.username&#125;&quot;</code>作用是从request参数中取参数</li>
</ul>
</li>
</ul>
<h2 id="显示登录信息"><a href="#显示登录信息" class="headerlink" title="显示登录信息"></a>显示登录信息</h2><p>功能：用户登录后，要显示用户的头像以及个人信息，头部显示首页和消息，不显示注册和登录。</p>
<h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p><code>HandlerInterceptor</code>类有三阶段：</p>
<ol>
<li><code>preHandle</code>: 在Controller之前执行</li>
<li><code>postHandle</code>: 在Controller之后执行</li>
<li><code>afterCompletion</code>: 在TemplateEngine之后执行</li>
</ol>
<p>拦截器实现后，需要在<code>WebMvcConfigurer</code>实现类中添加该拦截器，并设置排除对静态资源的拦截，以及需要拦截的页面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AlphaInterceptor alphaInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginTicketInterceptor loginTicketInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 静态资源可以访问</span></span><br><span class="line">        registry.addInterceptor(alphaInterceptor)</span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/**/*.css&quot;</span>, <span class="string">&quot;/**/*.js&quot;</span>, <span class="string">&quot;/**/*.png&quot;</span>, <span class="string">&quot;/**/*.jpg&quot;</span>, <span class="string">&quot;/**/*.jpeg&quot;</span>)</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/register&quot;</span>, <span class="string">&quot;/login&quot;</span>);</span><br><span class="line"></span><br><span class="line">        registry.addInterceptor(loginTicketInterceptor)</span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/**/*.css&quot;</span>, <span class="string">&quot;/**/*.js&quot;</span>, <span class="string">&quot;/**/*.png&quot;</span>, <span class="string">&quot;/**/*.jpg&quot;</span>, <span class="string">&quot;/**/*.jpeg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实现HostHolder对象"><a href="#实现HostHolder对象" class="headerlink" title="实现HostHolder对象"></a>实现<code>HostHolder</code>对象</h3><p>从线程中保存<code>user</code>、获取<code>user</code>，在线程结束时进行清理</p>
<p>线程在服务器处理完本次浏览器的请求后，线程结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HostHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        users.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> users.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        users.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="利用拦截器显示用户信息"><a href="#利用拦截器显示用户信息" class="headerlink" title="利用拦截器显示用户信息"></a>利用拦截器显示用户信息</h3><ol>
<li><p>在请求开始时，通过凭证找到用户，将用户存入<code>HostHolder</code>中</p>
</li>
<li><p>在模板引擎执行之前，获取用户</p>
</li>
<li><p>在模板引擎执行之后，清理数据</p>
</li>
<li><p><code>WebMvcConfigurer</code>实现类中添加拦截器</p>
</li>
<li><p>修改页面，未登录时看不到消息，没登陆时显示注册、登录（登录后不显示）</p>
</li>
</ol>
<h2 id="上传头像（文件）"><a href="#上传头像（文件）" class="headerlink" title="上传头像（文件）"></a>上传头像（文件）</h2><p><strong>上传文件：</strong></p>
<ul>
<li>必须是 <code>POST</code> 请求</li>
<li>表单要加上 <code>enctype=&quot;multipart/form-data&quot;</code></li>
<li>Spring MVC: 提供 <code>MultipartFile</code> 处理上传文件</li>
</ul>
<p><strong>开发步骤：</strong></p>
<ol>
<li>访问账号设置页面</li>
<li>处理表单，上传头像，存储图像（本地服务器）</li>
<li>增加一个请求：获取头像</li>
</ol>
<ul>
<li><code>Service层</code>：增加更新用户头像的方法</li>
<li><code>Controller层</code>：<br>  <strong>上传流程：</strong> 用户选择并上传文件，后端验证文件格式，生成随机文件名并保存文件到服务器，更新数据库中头像的 URL。<br>  <strong>获取流程：</strong> 用户请求头像文件，后端根据文件名读取服务器上的文件，设置合适的响应类型，并将图片文件传递给客户端。</li>
</ul>
<h2 id="更改密码（作业，自己写的）"><a href="#更改密码（作业，自己写的）" class="headerlink" title="更改密码（作业，自己写的）"></a>更改密码（作业，自己写的）</h2><p><strong>开发步骤：</strong></p>
<ol>
<li>访问账号设置页面</li>
<li>处理表单，更改密码</li>
</ol>
<ul>
<li><code>Service层</code>：增加更新用户密码的方法、校验旧密码是否正确</li>
<li><ul>
<li><code>Controller层</code>：<br>获取当前用户的原密码 -&gt;<br>校验用户输入的原密码是否与当前密码一致。如果不一致，添加错误信息并返回错误页面。 -&gt;<br>如果新密码和确认密码为空，添加错误信息。如果新密码和确认密码不一致，添加错误信息。确保新密码至少为 8 个字符长。如果不满足条件，添加错误信息。 -&gt;<br>校验完毕后，更新用户的密码。跳转登录页面。</li>
</ul>
</li>
</ul>
<h2 id="检查登录状态"><a href="#检查登录状态" class="headerlink" title="检查登录状态"></a>检查登录状态</h2><p>没登录前，在浏览器里输入一些的页面路径，要用拦截器拦截，不能访问。<br><strong>使用拦截器方法：</strong></p>
<ul>
<li>在方法钱标注自定义注解</li>
<li>拦截所有请求，只处理带有该注解的方法</li>
</ul>
<p><strong>自定义注解：</strong></p>
<ul>
<li><p>常用元注解：<br>  @Target（声明自定义注解可以作用在哪些类或方法上）<br>  @Retention（声明自定义注解有效时间）<br>  @Document（声明自定义注解在生成文档时是否要带）<br>  @Inherited（指定子类是否要继承父类的注解）<br>  举例：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span>  </span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LoginRequired &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何读取注解<br>  用到反射<br>  <code>Method.getDeclaredAnnotations()</code><br>  <code>Method.getAnnotation(Class&lt;T&gt; annotationClass)</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginRequiredInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> HostHolder hostHolder;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="comment">// 判断handle是否是方法  </span></span><br><span class="line">        <span class="keyword">if</span>(handler <span class="keyword">instanceof</span> HandlerMethod) &#123;  </span><br><span class="line">            <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> (HandlerMethod) handler;  </span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> handlerMethod.getMethod();  </span><br><span class="line">            <span class="comment">// 判断方法是否有这个注解  </span></span><br><span class="line">            <span class="type">LoginRequired</span> <span class="variable">loginRequired</span> <span class="operator">=</span> method.getAnnotation(LoginRequired.class);  </span><br><span class="line">            <span class="keyword">if</span>(loginRequired != <span class="literal">null</span> &amp;&amp; hostHolder.getUser() == <span class="literal">null</span>) &#123;  </span><br><span class="line">                <span class="comment">// 需要登录但是没登录  </span></span><br><span class="line">                response.sendRedirect(request.getContextPath() + <span class="string">&quot;/login&quot;</span>);  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p>为什么要把登录凭证保存到cookie</p>
<p>获取Cookie中的登录凭证，在每次请求时显示登录信息</p>
<p><img src="/2025/03/05/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE03-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/1.png" alt="1"></p>
</li>
<li><p>为什么表单上需要有<code>name</code>属性，提交给服务器才能获取</p>
<ul>
<li><code>name</code>属性用于标识表单控件，使浏览器在提交表单时能够正确地传递用户输入的数据。</li>
<li>服务器端依赖这些键值对来解析和处理表单数据。</li>
<li>如果表单控件没有<code>name</code>属性，控件的值不会被提交，导致服务器无法获取用户的输入数据。</li>
</ul>
</li>
<li><p>根据cookie中的登录凭证获取到用户后，怎么存？</p>
<p>不能存在session中，因为用户信息是隐私信息。也不能存在类中，因为浏览器有很多请求，一个服务器并发处理多个请求，需要隔离存储。</p>
<p>使用一个线程本地存储（ThreadLocal），用于存储当前线程的用户信息。在一次请求处理中，它的作用流程如下：</p>
<ul>
<li><strong>存储用户信息</strong>： 在请求开始时，从cookie中获取登录凭证，根据凭证查找用户信息，并将用户信息存储在<code>HostHolder</code>中。</li>
<li><strong>访问用户信息</strong>： 在整个请求处理过程中，业务逻辑可以随时从<code>HostHolder</code>中获取当前用户的信息，而无需再次查找或验证。</li>
<li><strong>清理用户信息</strong>： 请求处理完毕后，清理<code>HostHolder</code>中的用户信息，防止内存泄漏和数据污染。</li>
</ul>
</li>
<li><p>为什么要使用拦截器来设置<code>HostHolder</code></p>
<p>使用拦截器是为了在请求特定的阶段执行逻辑操作，拦截器有三个阶段，<code>preHandle</code>、<code>postHandle</code>、<code>afterCompletion</code></p>
</li>
</ol>
<h3 id="说说登录模块"><a href="#说说登录模块" class="headerlink" title="说说登录模块"></a>说说登录模块</h3><p>•	用户点击首页上的 登录按钮，服务端响应 登录页面。	<br>•	用户在 登录页面 上输入 用户名、密码、验证码，然后点击登录按钮，服务端接收到 POST 请求，验证账号和密码的正确性。<br>•	若 验证码错误，返回错误信息，提示 验证码不正确，跳转回登录页面。<br>•	若 账号不存在或密码错误，返回相关错误信息，跳转回登录页面。<br>•	若 账号和密码正确，则：<br>•	生成 登录凭证（ticket），存入数据库，并返回给客户端（Cookie 存储）。<br>•	若用户勾选 “记住我”，设置 较长的过期时间，否则使用默认的短时间登录状态。<br>•	服务端返回 首页，用户登录成功。</p>
]]></content>
      <categories>
        <category>Java项目</category>
      </categories>
      <tags>
        <tag>Java SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>学习小土堆pytorch教程记录-pytorch基础用法</title>
    <url>/2024/08/29/%E5%AD%A6%E4%B9%A0%E5%B0%8F%E5%9C%9F%E5%A0%86python%E6%95%99%E7%A8%8B%E8%AE%B0%E5%BD%95/%E5%AD%A6%E4%B9%A0%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch%E6%95%99%E7%A8%8B%E8%AE%B0%E5%BD%95-pytorch%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>继续学了，注意要多看官方文档，看源码，看模块的输入和输出</p>
<span id="more"></span>

<h1 id="1-python文件、python控制台和jupter的不同"><a href="#1-python文件、python控制台和jupter的不同" class="headerlink" title="1. python文件、python控制台和jupter的不同"></a>1. python文件、python控制台和jupter的不同</h1><p>运行同一块代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Start&quot;</span>)</span><br><span class="line">a = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">b = <span class="string">&quot;2024&quot;</span></span><br><span class="line">c = a + b</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure>
<p>python文件是以整体代码为一块运行的<br>python控制台是以每一行为一块运行的（也能以任意行运行）<br>jupyter是以任意行为块运行的<br>后两者，当某一块出错时，修改后前面的块并不需要再次运行。</p>
<table>
<thead>
<tr>
<th>运行方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>python文件</td>
<td>传播方便、适用大型项目</td>
<td>需要从头运行</td>
</tr>
<tr>
<td>python控制台</td>
<td>显示每个变量属性</td>
<td>不利于代码阅读和修改</td>
</tr>
<tr>
<td>jupyter</td>
<td>利于代码阅读和修改</td>
<td>环境需要配置</td>
</tr>
</tbody></table>
<h1 id="2-pytorch加载数据"><a href="#2-pytorch加载数据" class="headerlink" title="2. pytorch加载数据"></a>2. pytorch加载数据</h1><p>使用Dataset加载处理图像数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># help(Dataset)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承dataset类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root_dir, label_dir</span>): </span><br><span class="line">        self.root_dir = root_dir</span><br><span class="line">        self.label_dir = label_dir</span><br><span class="line">        self.path = os.path.join(self.root_dir, self.label_dir)</span><br><span class="line">        self.img_list = os.listdir(self.path)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        img_name = self.img_list[idx]</span><br><span class="line">        img_item_path = os.path.join(self.path, img_name)</span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_item_path)</span><br><span class="line">        label = self.label_dir</span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.img_list)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 实例化对象</span></span><br><span class="line">root_dir = <span class="string">&quot;dataset/train&quot;</span></span><br><span class="line">ants_label_dir = <span class="string">&quot;ants&quot;</span></span><br><span class="line">bees_label_dir = <span class="string">&quot;bees&quot;</span></span><br><span class="line">ants_dataset = MyData(root_dir, ants_label_dir)</span><br><span class="line">bees_dataset = MyData(root_dir, bees_label_dir)</span><br><span class="line"></span><br><span class="line">img, label = ants_dataset[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># img.show()</span></span><br><span class="line"></span><br><span class="line">train_data = ants_dataset + bees_dataset</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(train_data))</span><br><span class="line"></span><br><span class="line">img, label = train_data[<span class="number">125</span>]</span><br><span class="line">img.show()</span><br></pre></td></tr></table></figure>

<h1 id="3-Tensorboard的使用"><a href="#3-Tensorboard的使用" class="headerlink" title="3. Tensorboard的使用"></a>3. Tensorboard的使用</h1><p>安装tensorboard<br><code>conda install tensorboard</code><br>作用：画网格结构图，精确率、学习率、损失曲线</p>
<p><strong>add_scalar示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;y=2x&quot;</span>, i * <span class="number">2</span>, i)</span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<p>打开tensorboard查看：<br>(pytorch) D:\learning\pytorch&gt; tensorboard –logdir&#x3D;logs<br>指定端口打开：<br>(pytorch) D:\learning\pytorch&gt;tensorboard –logdir&#x3D;logs –port&#x3D;6007</p>
<p><strong>add_image示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># for i in range(100):</span></span><br><span class="line"><span class="comment">#     writer.add_scalar(&quot;y=2x&quot;, i * 3, i)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># writer.close()</span></span><br><span class="line"></span><br><span class="line">img_path = <span class="string">&quot;dataset/train/bees_image/16838648_415acd9e3f.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(img))</span><br><span class="line">numpy_img = np.array(img)</span><br><span class="line"><span class="built_in">print</span>(numpy_img.shape)</span><br><span class="line">writer.add_image(<span class="string">&quot;test&quot;</span>, numpy_img, <span class="number">2</span>, dataformats=<span class="string">&quot;HWC&quot;</span>)</span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>

<h1 id="3-Transform的使用"><a href="#3-Transform的使用" class="headerlink" title="3. Transform的使用"></a>3. Transform的使用</h1><p><strong>transform.ToTensor示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter </span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img_path = <span class="string">&quot;dataset/train/ants_image/0013035.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如何使用transforms</span></span><br><span class="line"><span class="comment"># tensor_img = transforms.ToTensor()(img)</span></span><br><span class="line">tensor_trans = transforms.ToTensor()</span><br><span class="line">tensor_img = tensor_trans(img)</span><br><span class="line"><span class="built_in">print</span>(tensor_img)</span><br><span class="line"></span><br><span class="line">writer.add_image(<span class="string">&quot;Tensor_img&quot;</span>, tensor_img)</span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>

<h1 id="4-常见的transforms"><a href="#4-常见的transforms" class="headerlink" title="4. 常见的transforms"></a>4. 常见的transforms</h1><h2 id="Normalize的使用"><a href="#Normalize的使用" class="headerlink" title="Normalize的使用"></a>Normalize的使用</h2><p>作用是将输入图像的像素值缩放到一个标准化的范围。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter </span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"></span><br><span class="line">img_path = <span class="string">&quot;dataset/train/ants_image/0013035.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line">tensor_trans = transforms.ToTensor()</span><br><span class="line">tensor_img = tensor_trans(img)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(tensor_img[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"><span class="comment"># Normalize使用</span></span><br><span class="line">trans_norm = transforms.Normalize([<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>], [<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>])</span><br><span class="line">img_norms =trans_norm(tensor_img)</span><br><span class="line"><span class="built_in">print</span>(img_norms[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">writer.add_image(<span class="string">&quot;Normalize_img&quot;</span>, img_norms)</span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>

<h2 id="Resize的使用"><a href="#Resize的使用" class="headerlink" title="Resize的使用"></a>Resize的使用</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Resize使用</span></span><br><span class="line"><span class="built_in">print</span>(img.size)</span><br><span class="line">trans_resize = transforms.Resize((<span class="number">512</span>, <span class="number">512</span>))</span><br><span class="line"><span class="comment"># img PIL -&gt; Resize -&gt; img_resize PIL</span></span><br><span class="line">img_resize = trans_resize(img)</span><br><span class="line"><span class="comment"># img_resize PIL -&gt; ToTensor -&gt; img_resize tensor</span></span><br><span class="line">img_resize = tensor_trans(img_resize)</span><br><span class="line"><span class="built_in">print</span>(img_resize.size)</span><br><span class="line">writer.add_image(<span class="string">&quot;Resize_img&quot;</span>, img_resize)</span><br></pre></td></tr></table></figure>

<h2 id="Compose的使用"><a href="#Compose的使用" class="headerlink" title="Compose的使用"></a>Compose的使用</h2><p>作用时将多个图像变换操作组合在一起，使得它们可以依次对图像进行处理。前一个操作的输出作为后一个操作的输入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Compose -&gt; Resize -&gt; ToTensor</span></span><br><span class="line">trans_resize_2 = transforms.Resize(<span class="number">512</span>)</span><br><span class="line"><span class="comment"># PIL -&gt; PIL -&gt; Tensor</span></span><br><span class="line">trans_compose = transforms.Compose([trans_resize_2, tensor_trans])</span><br><span class="line">img_resize_2 = trans_compose(img)</span><br><span class="line">writer.add_image(<span class="string">&quot;Resize_img_2&quot;</span>, img_resize_2)</span><br></pre></td></tr></table></figure>

<h2 id="RandomCrop使用"><a href="#RandomCrop使用" class="headerlink" title="RandomCrop使用"></a>RandomCrop使用</h2><p>作用是从图像中随机裁剪出一个指定大小的区域</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RandomCrop使用</span></span><br><span class="line">trans_crop = transforms.RandomCrop(<span class="number">256</span>)</span><br><span class="line">trans_compose_2 = transforms.Compose([trans_crop, tensor_trans])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    img_crop = trans_compose_2(img)</span><br><span class="line">    writer.add_image(<span class="string">&quot;RandomCrop_img&quot;</span>, img_crop, i)</span><br></pre></td></tr></table></figure>

<h1 id="5-使用torchvision提供的数据集"><a href="#5-使用torchvision提供的数据集" class="headerlink" title="5. 使用torchvision提供的数据集"></a>5. 使用torchvision提供的数据集</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line">dataset_transform = torchvision.transforms.Compose([</span><br><span class="line">    torchvision.transforms.ToTensor()</span><br><span class="line">])</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line"></span><br><span class="line">train_set = torchvision.datasets.CIFAR10(root=<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">True</span>, transform=dataset_transform, download=<span class="literal">True</span>)</span><br><span class="line">test_set = torchvision.datasets.CIFAR10(root=<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">False</span>, transform=dataset_transform, download=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(train_set[0])</span></span><br><span class="line"><span class="comment"># print(train_set.classes)</span></span><br><span class="line"><span class="comment"># img, target = train_set[0]</span></span><br><span class="line"><span class="comment"># print(img)</span></span><br><span class="line"><span class="comment"># print(target)</span></span><br><span class="line"><span class="comment"># img.show()</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(test_set[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    img, target = test_set[i]</span><br><span class="line">    writer.add_image(<span class="string">&quot;test_set&quot;</span>, img, i)</span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>

<h1 id="6-DataLoader的使用"><a href="#6-DataLoader的使用" class="headerlink" title="6. DataLoader的使用"></a>6. DataLoader的使用</h1><p>用于从 Dataset中批量加载数据，支持批量处理、打乱和并行加载等功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备的测试数据集</span></span><br><span class="line">test_set = torchvision.datasets.CIFAR10(root=<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor(), download=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># drop_last=True: 如果最后一个batch的数据量小于batch_size，就把这个batch丢掉</span></span><br><span class="line"><span class="comment"># shuffle=True: 每个epoch都打乱数据</span></span><br><span class="line">test_loader = DataLoader(test_set, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">0</span>, drop_last=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试数据中的第一张图片和target</span></span><br><span class="line">img, target = test_set[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(img.shape)</span><br><span class="line"><span class="built_in">print</span>(target)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    step = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> test_loader:</span><br><span class="line">        imgs, targets = data</span><br><span class="line">        <span class="comment"># print(imgs.shape)</span></span><br><span class="line">        <span class="comment"># print(targets)</span></span><br><span class="line">        writer.add_images(<span class="string">&quot;Epoch:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(epoch), imgs, step)</span><br><span class="line">        step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>深度学习 pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>学习小土堆pytorch教程记录-pytorch模型训练过程</title>
    <url>/2024/09/05/%E5%AD%A6%E4%B9%A0%E5%B0%8F%E5%9C%9F%E5%A0%86python%E6%95%99%E7%A8%8B%E8%AE%B0%E5%BD%95/%E5%AD%A6%E4%B9%A0%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch%E6%95%99%E7%A8%8B%E8%AE%B0%E5%BD%95-pytorch%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>现有网络模型的使用和修改、网络模型的保存和读取、完整的模型训练套路、使用GPU进行训练、完整的模型验证套路</p>
<p>算是学完了基础使用吧，但离实际操作还有很远。</p>
<p>代码的github仓库为：<a href="https://github.com/Eclipse-git725/pytorch">https://github.com/Eclipse-git725/pytorch</a></p>
<span id="more"></span>

<h1 id="1-现有网络模型的使用和修改"><a href="#1-现有网络模型的使用和修改" class="headerlink" title="1. 现有网络模型的使用和修改"></a>1. 现有网络模型的使用和修改</h1><p>官方文档：<a href="https://pytorch.org/vision/stable/index.html">https://pytorch.org/vision/stable/index.html</a><br>imgenet:<a href="https://pytorch.org/vision/0.9/datasets.html#imagenet">https://pytorch.org/vision/0.9/datasets.html#imagenet</a><br>需要先安装scipy包，<code>pip install scipy</code><br>pretrained为True时，模型是在数据集上已经训练好的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 太大了，147G</span></span><br><span class="line"><span class="comment"># dataset = torchvision.datasets.ImageNet(&quot;./dataset&quot;, split=&quot;train&quot;, transform=torchvision.transforms.ToTensor(), download=True)</span></span><br><span class="line"><span class="comment"># dataloader = torch.utils.data.DataLoader(dataset, batch_size=1, shuffle=True, drop_last=True)</span></span><br><span class="line"></span><br><span class="line">vgg16_false = torchvision.models.vgg16(pretrained=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># vgg16_true = torchvision.models.vgg16(pretrained=True)</span></span><br><span class="line"><span class="comment"># 调试，断点打到这里</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(vgg16_false)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迁移学习，根据现有网络改变它的结构</span></span><br><span class="line"><span class="comment"># 修改vgg16，in_features=1000，out_features=10</span></span><br><span class="line"><span class="comment"># vgg16_false.add_module(&quot;add_linear&quot;, nn.Linear(1000, 10))</span></span><br><span class="line"><span class="comment"># vgg16_false.classifier.add_module(&quot;add_linear&quot;, nn.Linear(1000, 10))</span></span><br><span class="line">vgg16_false.classifier[<span class="number">6</span>] = nn.Linear(<span class="number">4096</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(vgg16_false)</span><br></pre></td></tr></table></figure>

<h1 id="2-网络模型的保存和读取"><a href="#2-网络模型的保存和读取" class="headerlink" title="2. 网络模型的保存和读取"></a>2. 网络模型的保存和读取</h1><p>模型保存两种方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line">vgg16 = torchvision.models.vgg16(pretrained=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 保存方式1，模型结构和模型参数</span></span><br><span class="line">torch.save(vgg16, <span class="string">&#x27;vgg16_method1.pth&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存方式2，模型参数（官方推荐）</span></span><br><span class="line">torch.save(vgg16.state_dict(), <span class="string">&#x27;vgg16_method2.pth&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 陷阱</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.conv2d1 = nn.Conv2d(<span class="number">3</span>, <span class="number">64</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.conv2d1(x)</span><br><span class="line">    </span><br><span class="line">model = Model()</span><br><span class="line">torch.save(model, <span class="string">&quot;model_method1.pth&quot;</span>) </span><br></pre></td></tr></table></figure>

<p>模型读取两种方式（如果是自己定义的模型需要能访问到自己的模型结构才能加载）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> model_save <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取方式1</span></span><br><span class="line">model = torch.load(<span class="string">&#x27;vgg16_method1.pth&#x27;</span>)</span><br><span class="line"><span class="comment"># print(model)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取方式2</span></span><br><span class="line">model = torch.load(<span class="string">&#x27;vgg16_method2.pth&#x27;</span>)</span><br><span class="line"><span class="comment"># print(model)</span></span><br><span class="line"><span class="comment"># 只保存参数，如何恢复网络模型，load_state_dict参数里写字典</span></span><br><span class="line">vgg16 = torchvision.models.vgg16(pretrained=<span class="literal">False</span>)</span><br><span class="line">vgg16.load_state_dict(torch.load(<span class="string">&#x27;vgg16_method2.pth&#x27;</span>))</span><br><span class="line"><span class="comment"># print(vgg16)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 陷阱</span></span><br><span class="line"><span class="comment"># class Model(nn.Module):</span></span><br><span class="line"><span class="comment">#     def __init__(self):</span></span><br><span class="line"><span class="comment">#         super(Model, self).__init__()</span></span><br><span class="line"><span class="comment">#         self.conv2d1 = nn.Conv2d(3, 64, 3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     def forward(self, x):</span></span><br><span class="line"><span class="comment">#         return self.conv2d1(x)</span></span><br><span class="line"><span class="comment"># 只写load会报错，需要把模型定义写上，或者用import引入</span></span><br><span class="line">model = torch.load(<span class="string">&#x27;model_method1.pth&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(model)</span><br></pre></td></tr></table></figure>

<h1 id="3-完整的模型训练套路"><a href="#3-完整的模型训练套路" class="headerlink" title="3. 完整的模型训练套路"></a>3. 完整的模型训练套路</h1><ol>
<li>加载训练数据集和测试数据集</li>
<li>创建神经网络</li>
<li>创建损失函数</li>
<li>创建优化器</li>
<li>设置训练次数、测试次数和训练轮数</li>
<li>开始训练、测试，输出损失、准确率等，以及进行tensorboard可视化<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> model.model <span class="keyword">import</span> Model</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">train_set = torchvision.datasets.CIFAR10(root=<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">True</span>, transform=torchvision.transforms.ToTensor(), download=<span class="literal">True</span>)</span><br><span class="line">test_set = torchvision.datasets.CIFAR10(root=<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor(), download=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;训练数据集的长度为：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(train_set)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;测试数据集的长度为：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(test_set)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用DataLoader加载数据集</span></span><br><span class="line">train_dataloader = DataLoader(train_set, batch_size=<span class="number">64</span>, drop_last=<span class="literal">True</span>)</span><br><span class="line">test_dataloader = DataLoader(test_set, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搭建神经网络</span></span><br><span class="line">model = Model()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建损失函数</span></span><br><span class="line">loss_fn = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建优化器</span></span><br><span class="line">learning_rate = <span class="number">1e-2</span></span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置训练网络的参数</span></span><br><span class="line"><span class="comment"># 记录训练次数</span></span><br><span class="line">total_train_step = <span class="number">0</span></span><br><span class="line"><span class="comment"># 记录测试次数</span></span><br><span class="line">total_test_step = <span class="number">0</span></span><br><span class="line"><span class="comment"># 记录训练轮数</span></span><br><span class="line">epoch = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加tensorboard</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(epoch):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----------第&#123;&#125;轮训练开始---------&quot;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练步骤开始</span></span><br><span class="line">    <span class="comment"># 对特殊的层有影响，比如dropout和batchnorm</span></span><br><span class="line">    model.trian()</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> train_dataloader:</span><br><span class="line">        imgs, target = data</span><br><span class="line">        output = model(imgs)</span><br><span class="line">        loss = loss_fn(output, target)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 优化器优化模型</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        total_train_step += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(total_train_step % <span class="number">100</span> == <span class="number">0</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;训练次数：&#123;&#125;，loss：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_train_step, loss))</span><br><span class="line">            writer.add_scalar(<span class="string">&quot;train_loss&quot;</span>, loss.item(), total_train_step)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试步骤开始</span></span><br><span class="line">    <span class="comment"># 对特殊的层有影响，比如dropout和batchnorm</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    total_test_loss = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 分类中的重要参数，正确率</span></span><br><span class="line">    total_accuracy = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> test_dataloader:</span><br><span class="line">            imgs, target = data</span><br><span class="line">            output = model(imgs)</span><br><span class="line">            loss = loss_fn(output, target)</span><br><span class="line">            total_test_loss += loss</span><br><span class="line">            <span class="comment"># 计算正确率</span></span><br><span class="line">            accuracy = (output.argmax(<span class="number">1</span>) == target).<span class="built_in">sum</span>()</span><br><span class="line">            total_accuracy += accuracy</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;整体测试集上的loss为：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_test_loss))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;整体测试集上的正确率为：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_accuracy/<span class="built_in">len</span>(test_set)))</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;test_loss&quot;</span>, total_test_loss, total_test_step)</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;test_accuracy&quot;</span>, total_accuracy/<span class="built_in">len</span>(test_set), total_test_step)</span><br><span class="line">    total_test_step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存每一轮训练的模型</span></span><br><span class="line">    torch.save(model, <span class="string">&quot;model/model_&#123;&#125;.pth&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;模型已保存&quot;</span>)</span><br><span class="line"></span><br><span class="line">writer.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="4-使用GPU进行训练"><a href="#4-使用GPU进行训练" class="headerlink" title="4. 使用GPU进行训练"></a>4. 使用GPU进行训练</h1><p>只有模型、数据、损失函数可以调用.cuda()函数<br>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    model.cuda()</span><br><span class="line"></span><br><span class="line">loss_fn = nn.CrossEntropyLoss()</span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    loss_fn.cuda()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    imgs = imgs.cuda()</span><br><span class="line">    target = target.cuda()</span><br></pre></td></tr></table></figure>
<p>如果电脑没有GPU，可以使用google colab使用GPU训练，有免费额度。<br>使用手机Google可以不用开梯子，不用手机号，就注册上一个google邮箱。<br>设置使用GPU，可想jupyter一样使用。<br><img src="/2024/09/05/%E5%AD%A6%E4%B9%A0%E5%B0%8F%E5%9C%9F%E5%A0%86python%E6%95%99%E7%A8%8B%E8%AE%B0%E5%BD%95/%E5%AD%A6%E4%B9%A0%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch%E6%95%99%E7%A8%8B%E8%AE%B0%E5%BD%95-pytorch%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B/1.png" alt="1"></p>
<h1 id="5-完整的模型验证套路"><a href="#5-完整的模型验证套路" class="headerlink" title="5. 完整的模型验证套路"></a>5. 完整的模型验证套路</h1><p>利用已经训练好的模型，给它提供输入<br>若是拿GPU训练好的模型，在CPU上验证，在模型load时使用：<br><code>model = torch.load(&quot;./model/model_4.pth&quot;, map_location=torch.device(&#39;cpu&#39;))</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">img_path = <span class="string">&quot;./imgs/dog.png&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line"><span class="built_in">print</span>(img)</span><br><span class="line"></span><br><span class="line">transform = torchvision.transforms.Compose([</span><br><span class="line">    transforms.Resize((<span class="number">32</span>, <span class="number">32</span>)),</span><br><span class="line">    transforms.ToTensor()</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">img = transform(img)</span><br><span class="line"><span class="built_in">print</span>(img.shape)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        self.model = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Flatten(),</span><br><span class="line">            nn.Linear(<span class="number">1024</span>, <span class="number">64</span>),</span><br><span class="line">            nn.Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.model(x)</span><br><span class="line">    </span><br><span class="line">model = torch.load(<span class="string">&quot;./model/model_4.pth&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(model)</span><br><span class="line">img = torch.reshape(img, (<span class="number">1</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>))</span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    output = model(img)</span><br><span class="line"><span class="built_in">print</span>(output)</span><br><span class="line"><span class="built_in">print</span>(output.argmax(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>深度学习 pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>学习小土堆pytorch教程记录-环境配置</title>
    <url>/2024/07/31/%E5%AD%A6%E4%B9%A0%E5%B0%8F%E5%9C%9F%E5%A0%86python%E6%95%99%E7%A8%8B%E8%AE%B0%E5%BD%95/%E5%AD%A6%E4%B9%A0%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch%E6%95%99%E7%A8%8B%E8%AE%B0%E5%BD%95-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>好久没更了，破事太多了，论坛项目也得先放一放了，先入门pytorch吧，9小时争取尽快学完！</p>
<span id="more"></span>

<h1 id="1-安装anaconda3"><a href="#1-安装anaconda3" class="headerlink" title="1. 安装anaconda3"></a>1. 安装anaconda3</h1><p>anaconda：是包管理和环境管理工具。<br>官网：<a href="https://www.anaconda.com/download#">Download Anaconda Distribution | Anaconda</a><br>镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">Index of &#x2F;anaconda&#x2F;archive&#x2F; | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a><br>根据系统下载适合的版本：<br>下载了Anaconda3-2023.09-0-Windows-x86_64版本<br>一直点击下一步。<br>安装完后能打开Anaconda Prompt</p>
<h1 id="2-安装显卡驱动"><a href="#2-安装显卡驱动" class="headerlink" title="2. 安装显卡驱动"></a>2. 安装显卡驱动</h1><p>在任务管理器中GPU内，能看到显卡名即安装了驱动。</p>
<h1 id="3-安装一个环境"><a href="#3-安装一个环境" class="headerlink" title="3. 安装一个环境"></a>3. 安装一个环境</h1><p><strong>更改安装的环境位置：</strong><br>找到.condarc这个文件，加上一个配置，这样就会安装到anaconda的envs下了。更改路径后要给D盘的anaconda文件夹增加权限，所有用户都可读写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">envs_dirs:</span><br><span class="line">  - D:\anaconda\envs</span><br><span class="line">pkgs_dirs:</span><br><span class="line">  - D:\anaconda\pkgs</span><br></pre></td></tr></table></figure>

<p>打开Anaconda Prompt<br>输入：conda create -n pytorch python&#x3D;3.8<br>激活环境：conda activate pytorch<br>查看有哪些虚拟环境：conda env list<br>退出虚拟环境：conda deactivate<br>删除虚拟环境：conda remove –name env_name –all<br>根据有的配置文件创建环境：conda env create -f environment.yml</p>
<h1 id="4-安装pytorch"><a href="#4-安装pytorch" class="headerlink" title="4. 安装pytorch"></a>4. 安装pytorch</h1><p>pytorch官网：<a href="https://pytorch.org/">PyTorch</a><br>根据是否有GPU选择不同的版本：</p>
<h2 id="有GPU"><a href="#有GPU" class="headerlink" title="有GPU"></a>有GPU</h2><p><img src="/2024/07/31/%E5%AD%A6%E4%B9%A0%E5%B0%8F%E5%9C%9F%E5%A0%86python%E6%95%99%E7%A8%8B%E8%AE%B0%E5%BD%95/%E5%AD%A6%E4%B9%A0%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch%E6%95%99%E7%A8%8B%E8%AE%B0%E5%BD%95-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/1.png" alt="1"><br>pip3 install torch torchvision torchaudio –index-url <a href="https://download.pytorch.org/whl/cu118">https://download.pytorch.org/whl/cu118</a></p>
<h2 id="无GPU"><a href="#无GPU" class="headerlink" title="无GPU"></a>无GPU</h2><p><img src="/2024/07/31/%E5%AD%A6%E4%B9%A0%E5%B0%8F%E5%9C%9F%E5%A0%86python%E6%95%99%E7%A8%8B%E8%AE%B0%E5%BD%95/%E5%AD%A6%E4%B9%A0%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch%E6%95%99%E7%A8%8B%E8%AE%B0%E5%BD%95-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2.png" alt="2"><br>pip3 install torch torchvision torchaudio</p>
<p>验证pytorch是否安装成功：<br><img src="/2024/07/31/%E5%AD%A6%E4%B9%A0%E5%B0%8F%E5%9C%9F%E5%A0%86python%E6%95%99%E7%A8%8B%E8%AE%B0%E5%BD%95/%E5%AD%A6%E4%B9%A0%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch%E6%95%99%E7%A8%8B%E8%AE%B0%E5%BD%95-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/3.png" alt="3"></p>
<h1 id="5-配置jupyter程序"><a href="#5-配置jupyter程序" class="headerlink" title="5. 配置jupyter程序"></a>5. 配置jupyter程序</h1><p>jupyter是可交互的python编程<br>安装必要的包：conda install nb_conda<br>启动jupyter：jupyter notebook<br>启动后会在浏览器中运行jupyter</p>
<h1 id="6-vscode配置anaconda环境"><a href="#6-vscode配置anaconda环境" class="headerlink" title="6. vscode配置anaconda环境"></a>6. vscode配置anaconda环境</h1><p><strong>需要安装的插件：</strong> python、coder_runner<br>ctrl+shift+p打开后输入python select interpreter<br>find选择anaconda下的一个python.exe</p>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>深度学习 pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>学习小土堆pytorch教程记录-神经网络基础</title>
    <url>/2024/08/30/%E5%AD%A6%E4%B9%A0%E5%B0%8F%E5%9C%9F%E5%A0%86python%E6%95%99%E7%A8%8B%E8%AE%B0%E5%BD%95/%E5%AD%A6%E4%B9%A0%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch%E6%95%99%E7%A8%8B%E8%AE%B0%E5%BD%95-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>神经网络的基本骨架、卷积操作、卷积层、最大池化层、非线性激活、线性层、Sequential、损失函数、优化器</p>
<span id="more"></span>

<h1 id="1-神经网络的基本骨架"><a href="#1-神经网络的基本骨架" class="headerlink" title="1. 神经网络的基本骨架"></a>1. 神经网络的基本骨架</h1><p>官方文档：<a href="https://pytorch.org/docs/stable/nn.html">https://pytorch.org/docs/stable/nn.html</a><br>继承nn.Module</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span><br><span class="line">        output = <span class="built_in">input</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    </span><br><span class="line">model = Model()</span><br><span class="line"><span class="built_in">input</span> = torch.tensor(<span class="number">1</span>)</span><br><span class="line">output = model(<span class="built_in">input</span>)</span><br><span class="line"><span class="built_in">print</span>(output) </span><br></pre></td></tr></table></figure>

<h1 id="2-卷积操作"><a href="#2-卷积操作" class="headerlink" title="2. 卷积操作"></a>2. 卷积操作</h1><p>官方文档：<a href="https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html#torch.nn.Conv2d">https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html#torch.nn.Conv2d</a><br>stride的作用是卷积核每次移动的步长<br>padding的作用是在输入的边缘补0</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5x5的输入</span></span><br><span class="line"><span class="built_in">input</span> = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>], </span><br><span class="line">                      [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">                      [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                      [<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                      [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3x3的卷积核</span></span><br><span class="line">kernel = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">                       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">                       [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>.shape)</span><br><span class="line"><span class="built_in">print</span>(kernel.shape)</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span> = torch.reshape(<span class="built_in">input</span>, (<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">kernel = torch.reshape(kernel, (<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>.shape)</span><br><span class="line"><span class="built_in">print</span>(kernel.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># stride的作用是卷积核每次移动的步长</span></span><br><span class="line">output = F.conv2d(<span class="built_in">input</span>, kernel, stride=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(output)</span><br><span class="line"></span><br><span class="line">output2 = F.conv2d(<span class="built_in">input</span>, kernel, stride=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(output2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># padding的作用是在输入的边缘补0</span></span><br><span class="line">output3 = F.conv2d(<span class="built_in">input</span>, kernel, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(output3)</span><br></pre></td></tr></table></figure>

<h1 id="3-卷积层"><a href="#3-卷积层" class="headerlink" title="3. 卷积层"></a>3. 卷积层</h1><p>官方文档：<a href="https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html#torch.nn.Conv2d">https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html#torch.nn.Conv2d</a><br>示例：<a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md">https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md</a></p>
<ul>
<li><code>in_channels</code>：输入数据的通道数（例如，RGB图像的通道数为3）。</li>
<li><code>out_channels</code>：卷积核的数量，即输出的特征图数量。</li>
<li><code>kernel_size</code>：卷积核的大小，可以是一个整数或元组（如 <code>3</code> 或 <code>(3, 3)</code>）。</li>
<li><code>stride</code>：卷积操作的步长，默认为 <code>1</code>。</li>
<li><code>padding</code>：在输入的边缘补充的像素数，以控制输出的大小。</li>
<li><code>dilation</code>：卷积核元素之间的间距，默认为 <code>1</code>。</li>
<li><code>bias</code>：是否添加偏置项，默认为 <code>True</code>。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor(), download=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">dataload = DataLoader(dataset, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">6</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    </span><br><span class="line">model = Model()</span><br><span class="line"><span class="built_in">print</span>(model)</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line">step = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataload:</span><br><span class="line">    imgs, targets = data</span><br><span class="line">    output = model(imgs)</span><br><span class="line">    <span class="comment"># print(output.shape)</span></span><br><span class="line">    <span class="comment"># torch.Size([64, 3, 32, 32])</span></span><br><span class="line">    writer.add_images(<span class="string">&quot;input&quot;</span>, imgs, step)</span><br><span class="line">    <span class="comment"># torch.Size([64, 6, 30, 30])</span></span><br><span class="line"></span><br><span class="line">    output = torch.reshape(output, (-<span class="number">1</span>, <span class="number">3</span>, <span class="number">30</span>, <span class="number">30</span>))</span><br><span class="line">    writer.add_images(<span class="string">&quot;output&quot;</span>, output, step)</span><br><span class="line">    step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="4-最大池化层的使用"><a href="#4-最大池化层的使用" class="headerlink" title="4. 最大池化层的使用"></a>4. 最大池化层的使用</h1><p>官方文档：<a href="https://pytorch.org/docs/stable/generated/torch.nn.MaxPool2d.html#torch.nn.MaxPool2d">https://pytorch.org/docs/stable/generated/torch.nn.MaxPool2d.html#torch.nn.MaxPool2d</a><br>是下采样操作，用于减少数据的空间尺寸（宽度和高度），从而降低计算复杂度。池化层只保留局部区域的最大值，忽略其他较小的值，从而保留最显著的特征，抑制不重要的噪声。<br>参数<code>ceil_mode</code>决定了如何处理池化窗口的边界情况,</p>
<ul>
<li><strong><code>ceil_mode=False</code>（默认）</strong>：输出尺寸的计算采用 <code>floor</code>（向下取整），即舍去小数部分。这意味着在池化过程中，如果最后的窗口未完全覆盖输入的边界部分，则该窗口会被忽略。</li>
<li>**<code>ceil_mode=True</code>**：输出尺寸的计算采用 <code>ceil</code>（向上取整），即向上取整处理。在这种情况下，最后的池化窗口可以扩展到输入边界，即使该窗口未完全覆盖输入边界的数据也会参与计算。这会增加输出的尺寸。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5x5的输入</span></span><br><span class="line"><span class="built_in">input</span> = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>], </span><br><span class="line">                      [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">                      [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                      [<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                      [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="built_in">input</span> = <span class="built_in">input</span>.reshape(<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor(), download=<span class="literal">True</span>)</span><br><span class="line">dataload = DataLoader(dataset, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.maxpool = nn.MaxPool2d(kernel_size=<span class="number">3</span>, ceil_mode=<span class="literal">False</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        output = self.maxpool(x)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    </span><br><span class="line">model = Model()</span><br><span class="line"><span class="comment"># output = model(input)</span></span><br><span class="line"><span class="comment"># print(input.shape)</span></span><br><span class="line"><span class="comment"># print(output.shape)</span></span><br><span class="line"></span><br><span class="line">step = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataload:</span><br><span class="line">    imgs, targets = data</span><br><span class="line">    <span class="built_in">print</span>(imgs.shape)</span><br><span class="line">    output = model(imgs)</span><br><span class="line">    writer.add_images(<span class="string">&quot;input&quot;</span>, imgs, step)</span><br><span class="line">    writer.add_images(<span class="string">&quot;output&quot;</span>, output, step)</span><br><span class="line">    step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="5-非线性激活"><a href="#5-非线性激活" class="headerlink" title="5. 非线性激活"></a>5. 非线性激活</h1><p>官方文档：<a href="https://pytorch.org/docs/stable/nn.html#non-linear-activations-weighted-sum-nonlinearity">https://pytorch.org/docs/stable/nn.html#non-linear-activations-weighted-sum-nonlinearity</a><br>非线性激活函数使得神经网络能够学习和逼近复杂的非线性关系。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> ReLU</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Sigmoid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span> = torch.tensor([[<span class="number">1</span>, -<span class="number">1.5</span>],</span><br><span class="line">                      [-<span class="number">1</span>,<span class="number">3</span>]])</span><br><span class="line"><span class="built_in">input</span> = torch.reshape(<span class="built_in">input</span>, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor(), download=<span class="literal">True</span>)</span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.relu = ReLU()</span><br><span class="line">        self.sigmoid = Sigmoid()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># output = self.relu(x)</span></span><br><span class="line">        output = self.sigmoid(x)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">model = Model()</span><br><span class="line"><span class="comment"># output = model(input)</span></span><br><span class="line"><span class="comment"># # tensor([[[1., 0.],[0., 3.]]])</span></span><br><span class="line"><span class="comment"># print(output)</span></span><br><span class="line"></span><br><span class="line">step = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataloader:</span><br><span class="line">    imgs, targets = data</span><br><span class="line">    output = model(imgs)</span><br><span class="line">    writer.add_images(<span class="string">&quot;input&quot;</span>, imgs, step)</span><br><span class="line">    writer.add_images(<span class="string">&quot;output&quot;</span>, output, step)</span><br><span class="line">    step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>

<h1 id="6-线性层"><a href="#6-线性层" class="headerlink" title="6. 线性层"></a>6. 线性层</h1><p>线性层官方文档：<a href="https://pytorch.org/docs/stable/generated/torch.nn.Linear.html#torch.nn.Linear">https://pytorch.org/docs/stable/generated/torch.nn.Linear.html#torch.nn.Linear</a><br>线性层可以改变数据的维度，例如在卷积神经网络中，将卷积层的输出展平（flatten）后通过线性层，将特征映射到最终的类别空间或回归目标空间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor(), download=<span class="literal">True</span>)</span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>, drop_last=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.linear = nn.Linear(<span class="number">196608</span>, <span class="number">10</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        output = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    </span><br><span class="line">model = Model()</span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataloader:</span><br><span class="line">    img, taget = data</span><br><span class="line">    <span class="built_in">print</span>(img.shape)</span><br><span class="line">    <span class="comment"># output = torch.reshape(img, (1, 1, 1, -1))</span></span><br><span class="line">    output = torch.flatten(img)</span><br><span class="line">    <span class="built_in">print</span>(output.shape)</span><br><span class="line">    output = model(output)</span><br><span class="line">    <span class="built_in">print</span>(output.shape)</span><br></pre></td></tr></table></figure>

<h1 id="7-Sequential使用"><a href="#7-Sequential使用" class="headerlink" title="7. Sequential使用"></a>7. Sequential使用</h1><p>用于将多个层按顺序组合在一起。它的主要用途是简化模型的定义，使代码更加简洁和易读。<br>CIFRA10数据训练的模型结构如下图：<br><img src="/2024/08/30/%E5%AD%A6%E4%B9%A0%E5%B0%8F%E5%9C%9F%E5%A0%86python%E6%95%99%E7%A8%8B%E8%AE%B0%E5%BD%95/%E5%AD%A6%E4%B9%A0%E5%B0%8F%E5%9C%9F%E5%A0%86pytorch%E6%95%99%E7%A8%8B%E8%AE%B0%E5%BD%95-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/1.png" alt="1"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Conv2d, MaxPool2d, Flatten, Linear</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.conv1 = Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">32</span>, kernel_size=<span class="number">5</span>, stride=<span class="number">1</span>, padding=<span class="number">2</span>)</span><br><span class="line">        self.maxpool1 = MaxPool2d(<span class="number">2</span>)</span><br><span class="line">        self.conv2 = Conv2d(in_channels=<span class="number">32</span>, out_channels=<span class="number">32</span>, kernel_size=<span class="number">5</span>, stride=<span class="number">1</span>, padding=<span class="number">2</span>)</span><br><span class="line">        self.maxpool2 = MaxPool2d(<span class="number">2</span>)</span><br><span class="line">        self.conv3 = Conv2d(in_channels=<span class="number">32</span>, out_channels=<span class="number">64</span>, kernel_size=<span class="number">5</span>, stride=<span class="number">1</span>, padding=<span class="number">2</span>)</span><br><span class="line">        self.maxpool3 = MaxPool2d(<span class="number">2</span>)</span><br><span class="line">        self.flatten = Flatten()</span><br><span class="line">        self.linear1 = Linear(<span class="number">1024</span>, <span class="number">64</span>)</span><br><span class="line">        self.linear2 = Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># sequential的使用</span></span><br><span class="line">        self.model1 = nn.Sequential(</span><br><span class="line">            Conv2d(<span class="number">3</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Flatten(),</span><br><span class="line">            Linear(<span class="number">1024</span>, <span class="number">64</span>),</span><br><span class="line">            Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># x = self.conv1(x)</span></span><br><span class="line">        <span class="comment"># x = self.maxpool1(x)</span></span><br><span class="line">        <span class="comment"># x = self.conv2(x)</span></span><br><span class="line">        <span class="comment"># x = self.maxpool2(x)</span></span><br><span class="line">        <span class="comment"># x = self.conv3(x)</span></span><br><span class="line">        <span class="comment"># x = self.maxpool3(x)</span></span><br><span class="line">        <span class="comment"># x = self.flatten(x)</span></span><br><span class="line">        <span class="comment"># x = self.linear1(x)</span></span><br><span class="line">        <span class="comment"># x = self.linear2(x)</span></span><br><span class="line">        x = self.model1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    </span><br><span class="line">model = Model()</span><br><span class="line"><span class="built_in">print</span>(model)</span><br><span class="line"><span class="built_in">input</span> = torch.ones((<span class="number">64</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>))</span><br><span class="line">output = model(<span class="built_in">input</span>)</span><br><span class="line"><span class="built_in">print</span>(output.shape)</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line">writer.add_graph(model, <span class="built_in">input</span>)</span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>

<h1 id="8-损失函数"><a href="#8-损失函数" class="headerlink" title="8. 损失函数"></a>8. 损失函数</h1><p>计算和实际输出之间的差距<br>为反向传播提供依据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> L1Loss, MSELoss</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span> = torch.tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=torch.float32)</span><br><span class="line">target = torch.tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], dtype=torch.float32)</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span> = torch.reshape(<span class="built_in">input</span>, (<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">target = torch.reshape(target, (<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># loss = L1Loss()</span></span><br><span class="line">loss = L1Loss(reduction=<span class="string">&quot;sum&quot;</span>)</span><br><span class="line">result = loss(<span class="built_in">input</span>, target)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">loss_mes = MSELoss()</span><br><span class="line">result_mes = loss_mes(<span class="built_in">input</span>, target)</span><br><span class="line"><span class="built_in">print</span>(result_mes)</span><br><span class="line"></span><br><span class="line">x = torch.tensor([<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>])</span><br><span class="line">y = torch.tensor([<span class="number">1</span>])</span><br><span class="line">x = torch.reshape(x, (<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">loss_cross = torch.nn.CrossEntropyLoss()</span><br><span class="line">result_cross = loss_cross(x, y)</span><br><span class="line"><span class="built_in">print</span>(result_cross)</span><br></pre></td></tr></table></figure>

<p><strong>在神经网络中如何使用损失函数：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Conv2d, MaxPool2d, Flatten, Linear</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># sequential的使用</span></span><br><span class="line">        self.model1 = nn.Sequential(</span><br><span class="line">            Conv2d(<span class="number">3</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Flatten(),</span><br><span class="line">            Linear(<span class="number">1024</span>, <span class="number">64</span>),</span><br><span class="line">            Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.model1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    </span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor(), download=<span class="literal">True</span>)</span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">1</span>, shuffle=<span class="literal">True</span>, drop_last=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># writer = SummaryWriter(&quot;logs&quot;)</span></span><br><span class="line">model = Model()</span><br><span class="line">loss = nn.CrossEntropyLoss()</span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataloader:</span><br><span class="line">    imgs, targets = data</span><br><span class="line">    output = model(imgs)</span><br><span class="line">    <span class="built_in">print</span>(output)</span><br><span class="line">    <span class="built_in">print</span>(targets)</span><br><span class="line">    result_loss = loss(output, targets)</span><br><span class="line">    <span class="built_in">print</span>(result_loss)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="9-优化器"><a href="#9-优化器" class="headerlink" title="9. 优化器"></a>9. 优化器</h1><p>根据计算得到的梯度来更新模型的参数，以最小化损失函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Conv2d, MaxPool2d, Flatten, Linear</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># sequential的使用</span></span><br><span class="line">        self.model1 = nn.Sequential(</span><br><span class="line">            Conv2d(<span class="number">3</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Flatten(),</span><br><span class="line">            Linear(<span class="number">1024</span>, <span class="number">64</span>),</span><br><span class="line">            Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.model1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    </span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor(), download=<span class="literal">True</span>)</span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">1</span>, shuffle=<span class="literal">True</span>, drop_last=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># writer = SummaryWriter(&quot;logs&quot;)</span></span><br><span class="line">model = Model()</span><br><span class="line">loss = nn.CrossEntropyLoss()</span><br><span class="line">optim = torch.optim.SGD(model.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> dataloader:</span><br><span class="line">        imgs, targets = data</span><br><span class="line">        output = model(imgs)</span><br><span class="line">        result_loss = loss(output, targets)</span><br><span class="line">        optim.zero_grad()</span><br><span class="line">        result_loss.backward()</span><br><span class="line">        optim.step()</span><br><span class="line">        running_loss += result_loss</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;epoch: <span class="subst">&#123;epoch&#125;</span>, loss: <span class="subst">&#123;running_loss&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>深度学习 pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>仿牛客论坛项目04-核心社区功能</title>
    <url>/2025/03/08/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE04-%E6%A0%B8%E5%BF%83%E7%A4%BE%E5%8C%BA%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>仿牛客论坛项目04-核心社区功能，内容记录。</p>
<p>字典树过滤敏感词、事务管理、统一异常管理、AOP 记录日志</p>
<span id="more"></span>

<h2 id="过滤敏感词"><a href="#过滤敏感词" class="headerlink" title="过滤敏感词"></a>过滤敏感词</h2><p>使用字典树（Trie树、前缀树）过滤敏感词<br>应用：字符串检索、词频统计、字符串排序</p>
<p>实现敏感词过滤器方法：</p>
<ul>
<li>定义前缀树</li>
<li>根据敏感词，初始化前缀树</li>
<li>编写过滤敏感词方法<br><img src="/2025/03/08/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE04-%E6%A0%B8%E5%BF%83%E7%A4%BE%E5%8C%BA%E5%8A%9F%E8%83%BD/1.png" alt="1"></li>
</ul>
<p>注意：<br>需要考虑敏感词之间有符号的情况。<br>核心代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">filter</span><span class="params">(String text)</span> &#123;  </span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">tempNode</span> <span class="operator">=</span> rootNode; <span class="comment">// 指针1  </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 指针2  </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 指针3  </span></span><br><span class="line">    <span class="comment">// 结果  </span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();  </span><br><span class="line">    <span class="keyword">while</span>(position &lt; text.length()) &#123;  </span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> text.charAt(position);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 跳过符号  </span></span><br><span class="line">        <span class="keyword">if</span>(isSymbol(c)) &#123;  </span><br><span class="line">            <span class="comment">// 若指针1处于根节点，将此符号计入结果，指针2向下走一步  </span></span><br><span class="line">            <span class="keyword">if</span>(tempNode == rootNode) &#123;  </span><br><span class="line">                sb.append(c);  </span><br><span class="line">                begin ++;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// 无论符号在开头还是中间，指针3都向下走一步  </span></span><br><span class="line">            position ++;  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 检查下级节点  </span></span><br><span class="line">        tempNode = tempNode.getSubNode(c);  </span><br><span class="line">        <span class="keyword">if</span>(tempNode == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="comment">// 已begin开头的字符串不是敏感词  </span></span><br><span class="line">            sb.append(text.charAt(begin));  </span><br><span class="line">            <span class="comment">// 进入下个位置  </span></span><br><span class="line">            position = ++begin;  </span><br><span class="line">            <span class="comment">// 重新指向根节点  </span></span><br><span class="line">            tempNode = rootNode;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(tempNode.isEnd()) &#123;  </span><br><span class="line">            <span class="comment">// 发现敏感词，将begin-position字符串替换掉  </span></span><br><span class="line">            sb.append(REPLACEMENT);  </span><br><span class="line">            <span class="comment">// 进入下一个位置  </span></span><br><span class="line">            begin = ++position;  </span><br><span class="line">            tempNode = rootNode;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// 继续检查下一个字符  </span></span><br><span class="line">            position ++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 将最后一批字符计入结果，指针2疑似敏感词，指针3已经到结尾，不是敏感词  </span></span><br><span class="line">    sb.append(text.substring(begin));  </span><br><span class="line">    <span class="keyword">return</span> sb.toString();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="发布帖子"><a href="#发布帖子" class="headerlink" title="发布帖子"></a>发布帖子</h2><p><strong>AJAX：</strong></p>
<ul>
<li>Asynchronous JavaScript ans XML</li>
<li>不需要刷新整个页面，能将增量显示在页面上</li>
</ul>
<p>示例：页面上点发送按钮，服务器返回数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://code.jquery.com/jquery-3.3.1.min.js&quot;</span> crossorigin=<span class="string">&quot;anonymous&quot;</span>&gt;&lt;/script&gt;  </span><br><span class="line">&lt;script&gt;  </span><br><span class="line">    function <span class="title function_">send</span><span class="params">()</span> &#123;  </span><br><span class="line">        $.post(  </span><br><span class="line">            <span class="string">&quot;/community/alpha/ajax&quot;</span>,  </span><br><span class="line">            &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;gxy&quot;</span>, <span class="string">&quot;age&quot;</span>:<span class="number">23</span>&#125;,  </span><br><span class="line">            function (data) &#123;  </span><br><span class="line">                <span class="comment">// 回调函数，服务器返回给浏览器的对象  </span></span><br><span class="line">                console.log(typeof(data));  </span><br><span class="line">                console.log(data);  </span><br><span class="line">  </span><br><span class="line">                data = $.parseJSON(data);  </span><br><span class="line">                console.log(typeof(data));  </span><br><span class="line">                console.log(data.code);  </span><br><span class="line">                console.log(data.msg);  </span><br><span class="line">            &#125;  </span><br><span class="line">        );  </span><br><span class="line">    &#125;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Dao-层"><a href="#Dao-层" class="headerlink" title="Dao 层"></a>Dao 层</h3><p>增加帖子的方法，并在mybatis mapper中实现数据库语句<br>写完需要进行测试。</p>
<h3 id="Service-层"><a href="#Service-层" class="headerlink" title="Service 层"></a>Service 层</h3><p>添加帖子时的处理逻辑：</p>
<ol>
<li>参数不能为空</li>
<li>对 HTML 标记进行转义，方法<code>HtmlUtils.htmlEscape()</code></li>
<li>过滤敏感词</li>
</ol>
<h3 id="Controller-层"><a href="#Controller-层" class="headerlink" title="Controller 层"></a>Controller 层</h3><p>页面上只需要传入标题和内容（参数）。<br>Controller 层逻辑：</p>
<ol>
<li>判断用户是否登录</li>
<li>创建一个帖子的对象</li>
<li>返回 JSON 字符串</li>
</ol>
<h3 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h3><p>实现逻辑：</p>
<ol>
<li>没登录时，不显示“我要发布”的按钮</li>
<li>JS 中获取标题和内容</li>
<li>发送异步请求</li>
<li>在异步请求的回调函数中，将提示消息更新到页面</li>
</ol>
<h2 id="显示帖子详情"><a href="#显示帖子详情" class="headerlink" title="显示帖子详情"></a>显示帖子详情</h2><h3 id="Dao、Service、Controller-层"><a href="#Dao、Service、Controller-层" class="headerlink" title="Dao、Service、Controller 层"></a>Dao、Service、Controller 层</h3><p>增加查看帖子的方法</p>
<h3 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h3><p>在帖子标题上增加访问详情页面的链接</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;|/discuss/detail/$&#123;map.post.id&#125;|&#125;&quot;</span> <span class="attr">th:utext</span>=<span class="string">&quot;$&#123;map.post.title&#125;&quot;</span>&gt;</span>xxx  </span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="discuss-detail-html"><a href="#discuss-detail-html" class="headerlink" title="discuss-detail.html"></a>discuss-detail.html</h3><ul>
<li>处理静态资源的访问路径</li>
<li>复用 <code>index.html</code> 的 <code>header</code> 区域</li>
<li>显示标题、作者、发布时间、帖子正文等内容</li>
</ul>
<h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><p><strong>定义：</strong> 有N步数据库操作序列组成的逻辑执行单元，这系列操作要么全执行，要么全放弃执行<br><strong>事务的特性（ACID）：</strong></p>
<ul>
<li>原子性（Atomicity）：事务是最小的执行体</li>
<li>一致性（Consistency）：事务执行的结果，是数据从一个一致性状态，变为另一个一致性状态</li>
<li>隔离性（Isolation）：各个事务内部的操作互不干扰</li>
<li>持久性（Durability）：事务一旦提交，对数据做的改变都要记录到永久存储器中</li>
</ul>
<p><strong>事务的隔离性：</strong></p>
<ul>
<li>常见的并发异常：<br>  第一类丢失更新（某一个事务的回滚导致另一个事务已更新的数据丢失 ）、第二类丢失更新（某一个事务的提交导致另一个事务已更新的数据丢失）<br>  脏读（某一个事务读取了另一个事务未提交的数据）、不可重复读（某一个事务，对同一个数据前后读取结果不一致）、幻读（某一个事务，对同一个表前后查询到的行数不一致）</li>
<li>常见的隔离级别<br>  Read Uncommitted：读取未提交的数据<br>  Read Committed：读取已提交的数据<br>  Repeatable Read：可重复读<br>  Serializable：串行化 （会加很多锁，降低执行效率）</li>
</ul>
<p><strong>数据库保障事务的实现机制：</strong></p>
<ul>
<li>悲观锁（数据库自带）<ul>
<li>共享锁（S锁）：事务A对某数据加了共享锁后，其他事务职能加共享锁，不能加排他锁</li>
<li>排他锁（X锁）：事务A对某数据加了排他锁后，其他事务对该数据既不能加共享锁，也不能加排他锁</li>
</ul>
</li>
<li>乐观锁（自定义）<br>  使用版本号、时间戳等<br>  在更新数据钱，检查版本是否发生变化，若变化则取消本次更新，否则就更新数据（版本号+1）</li>
</ul>
<p><strong>使用注解管理事务</strong><br><code>@Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED)</code><br>传播方式 <code>propagation</code> 是一个方法调用另一个事务管理的方法，该用哪一种隔离级别，传播机制就就是用来解决这种问题，常用有三种：</p>
<ul>
<li><code>REQUIRED</code>：支持当前事务（或者说外部事务，A调用B，A是当前事务），如果不存在则创建新事务</li>
<li><code>REQUIRES_NEW</code>：创建一个新事物，并且暂停当前事务</li>
<li><code>NESTED</code>：如果当前存在事务（外部事务），则嵌套在该事务中执行（但有独立的提交和回滚），否则和REQUIRED一致</li>
</ul>
<h2 id="显示评论"><a href="#显示评论" class="headerlink" title="显示评论"></a>显示评论</h2><h3 id="数据层"><a href="#数据层" class="headerlink" title="数据层"></a>数据层</h3><ul>
<li>根据实体查询一页评论数据</li>
<li>根据实体查询评论的数量</li>
</ul>
<h3 id="业务层"><a href="#业务层" class="headerlink" title="业务层"></a>业务层</h3><ul>
<li>处理查询评论业务</li>
<li>处理查询评论数量的业务</li>
</ul>
<h3 id="表现层"><a href="#表现层" class="headerlink" title="表现层"></a>表现层</h3><ul>
<li>显示帖子详情数据时，同时显示该帖子所有的评论数据</li>
<li>每个评论的回复也要同时查询评论的所有回复数据</li>
</ul>
<h2 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h2><h3 id="数据层-1"><a href="#数据层-1" class="headerlink" title="数据层"></a>数据层</h3><ul>
<li>增加评论（<code>CommentMapper</code> 中实现）</li>
<li>修改评论的数量（<code>discuss_post</code> 表中有个参数是评论数量，<code>DiscussPostMapper</code> 中实现 ）</li>
</ul>
<h3 id="业务层-1"><a href="#业务层-1" class="headerlink" title="业务层"></a>业务层</h3><ul>
<li>处理增加评论业务（核心业务，在这用事务管理，要先判空，再 转义HTML，再过滤敏感词）</li>
<li>先增加评论，再更新帖子评论的数量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Isolation.READ_COMMITTED 作用：当前事务只能读取到已提交的数据</span></span><br><span class="line"><span class="meta">@Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addComment</span><span class="params">(Comment comment)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span>(comment == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不能为空！&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 转义comment  </span></span><br><span class="line">    comment.setContent(HtmlUtils.htmlEscape(comment.getContent()));  </span><br><span class="line">    <span class="comment">// 过滤敏感词  </span></span><br><span class="line">    comment.setContent(sensitiveFilter.filter(comment.getContent()));  </span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> commentMapper.insertComment(comment);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 更新帖子评论数量  </span></span><br><span class="line">    <span class="keyword">if</span>(comment.getEntityType() == ENTITY_TYPE_COMMENT) &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> commentMapper.selectCommentsRows(comment.getEntityType(), comment.getEntityId());  </span><br><span class="line">        discussPostService.updateCommentCount(comment.getEntityId(), count);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> rows;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="表现层-1"><a href="#表现层-1" class="headerlink" title="表现层"></a>表现层</h3><ul>
<li>处理添加评论数据的请求</li>
<li>设置添加评论的表单</li>
</ul>
<h2 id="私信列表"><a href="#私信列表" class="headerlink" title="私信列表"></a>私信列表</h2><p>业务逻辑：</p>
<ul>
<li>私信列表<ul>
<li>查询当前用户的会话列表，每个会话只显示一条最新的私信</li>
<li>支持分页显示</li>
</ul>
</li>
<li>私信详情<ul>
<li>查询某个会话所包含的私信</li>
<li>支持分页显示</li>
</ul>
</li>
</ul>
<h3 id="数据层-2"><a href="#数据层-2" class="headerlink" title="数据层"></a>数据层</h3><p><code>MessageMapper</code> 有五个方法：<br>查询一页数据、查询数据总行数。点击一个会话进入后也要这两个方法<br>查询未读消息数量（针对某个会话、针对所有会话）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 对于每个 conversation_id，找到 id 最大的消息（通常代表该会话中最新的消息）。</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(id) <span class="keyword">from</span> message </span><br><span class="line"><span class="keyword">where</span> status <span class="operator">!=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">and</span> from_id <span class="operator">!=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> conversation_id</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 这个 <span class="keyword">IN</span> 子查询的作用是 找到每个会话中 id 最大的消息（即最新消息），然后从 message 表中查询这些消息的完整信息。</span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;selectConversations&quot; resultType<span class="operator">=</span>&quot;Message&quot;<span class="operator">&gt;</span>  </span><br><span class="line">    <span class="keyword">select</span> <span class="operator">&lt;</span>include refid<span class="operator">=</span>&quot;selectField&quot;<span class="operator">&gt;</span><span class="operator">&lt;</span><span class="operator">/</span>include<span class="operator">&gt;</span>  </span><br><span class="line">    <span class="keyword">from</span> message  </span><br><span class="line">    <span class="keyword">where</span> id <span class="keyword">in</span> (  </span><br><span class="line">        <span class="keyword">select</span> <span class="built_in">max</span>(id)  </span><br><span class="line">        <span class="keyword">from</span> message  </span><br><span class="line">        <span class="keyword">where</span> status <span class="operator">!=</span> <span class="number">2</span>  </span><br><span class="line">        <span class="keyword">and</span> from_id <span class="operator">!=</span> <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">and</span> (from_id <span class="operator">=</span> #&#123;userId&#125; <span class="keyword">or</span> to_id <span class="operator">=</span> #&#123;userId&#125;)  </span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span> conversation_id  </span><br><span class="line">    )  </span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span>  </span><br><span class="line">    # 分页查询语句  </span><br><span class="line">    limit #&#123;<span class="keyword">offset</span>&#125;, #&#123;limit&#125;  </span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 这个<span class="keyword">sql</span>是统计子查询最大id的数量</span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;selectConversationCount&quot; resultType<span class="operator">=</span>&quot;int&quot;<span class="operator">&gt;</span>  </span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">count</span>(m.maxid) <span class="keyword">from</span> (  </span><br><span class="line">        <span class="keyword">select</span> <span class="built_in">max</span>(id) <span class="keyword">as</span> maxid  </span><br><span class="line">        <span class="keyword">from</span> message  </span><br><span class="line">        <span class="keyword">where</span> status <span class="operator">!=</span> <span class="number">2</span>  </span><br><span class="line">        <span class="keyword">and</span> from_id <span class="operator">!=</span> <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">and</span> (from_id <span class="operator">=</span> #&#123;userId&#125; <span class="keyword">or</span> to_id <span class="operator">=</span> #&#123;userId&#125;)  </span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span> conversation_id  </span><br><span class="line">    ) <span class="keyword">as</span> m  </span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="发送私信"><a href="#发送私信" class="headerlink" title="发送私信"></a>发送私信</h2><ul>
<li>发送私信<ul>
<li>采用异步方式发送私信</li>
<li>发送成功后刷新私信列表</li>
</ul>
</li>
<li>设置已读<ul>
<li>访问私信详情时，将私信设置为已读状态<br>  在用户打开私信详情页面时，如果有未读消息，就变成已读。</li>
</ul>
</li>
</ul>
<h2 id="统一处理异常"><a href="#统一处理异常" class="headerlink" title="统一处理异常"></a>统一处理异常</h2><ul>
<li>SpringBoot 自动处理，将错误提示页面放在<code>/template/error</code> 目录下，文件名为错误码：404、500</li>
<li>需要记录日志，用到注解<ul>
<li>@ControllerAdvice：修饰类，全局统一配置。处理异常、绑定数据、绑定参数（修饰方法）<ul>
<li>处理异常：@ExceptionHandler，优点：统一处理，不用在任何一个 Controller 上处理</li>
<li>绑定数据：@ModelAttribute</li>
<li>绑定参数：@DataBinder</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="统一记录日志"><a href="#统一记录日志" class="headerlink" title="统一记录日志"></a>统一记录日志</h2><p>不发生异常，也需要记录日志。也不能用拦截器，因为还要记录数据层、业务层。<br>业务层是专门处理业务的，在业务层中记录日志不专业，记录业务是系统需求，增加了耦合性。<br>使用 AOP 解决。</p>
<h3 id="AOP-概念"><a href="#AOP-概念" class="headerlink" title="AOP 概念"></a>AOP 概念</h3><p>Aspect Oriented Programing，面向方面（切面）编程，对 OOP 的补充。（概念抽象）<br>通俗理解：系统有很多业务模块，每个业务模块都有相同的需求，如记录日志，</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p>为什么要对用户输入的标题进行 HTMl 转义<br> 如果不转义，将用户输入的<code>&lt;h1&gt;&lt;script&gt;alert(&quot;XSS攻击成功！&quot;)&lt;/script&gt;&lt;/h1&gt;</code> 存进数据库中，页面加载时，JS 代码会被执行，弹出弹框。<br> 跳转到钓鱼网站 <code>&lt;a href=&quot;http://phishing.com&quot;&gt;点击这里领奖&lt;/a&gt;</code><br> 攻击者会注入恶意脚本，造成严重的安全漏洞。<br> 正确做法：在 <code>service</code> 层对标题等用户输入的内容进行 HTML 转义，防止安全漏洞。</p>
</li>
<li><p>说说评论功能<br> 评论功能主要分为两种：对帖子评论（一级评论） 和 对评论的回复（二级评论）。<br> 用户在帖子详情页发表评论：<br> •	服务器接收评论请求，判断评论类型：<br> •	如果是帖子评论，存入数据库，并更新帖子的评论数量。<br> •	如果是对评论的回复，存入数据库，并记录 target_id 以标记被回复的用户。<br> 数据库设计：<br> • comment 表通过 entity_type 和 entity_id 关联 <strong>帖子或评论</strong>。<br> • target_id 记录被回复用户 ID。<br> 事务管理：<br> @Transactional 保证评论插入和帖子评论数更新是原子操作，防止数据不一致。</p>
</li>
<li><p>为了发送私信异步请求，要加上 <code>@ResponseBody</code> 这个注解<br> 在发送私信的异步请求（AJAX 请求）时，通常希望服务器返回一个 <strong>JSON 结构的响应</strong>，而不是一个 HTML 页面，因此需要加上 @ResponseBody。<br> 不加这个注解，默认返回的是页面。</p>
</li>
<li><p>为了提交私信时，status 状态是0，但发送者中是已读，接受者中是未读，明明数据库中都是一条数据？<br> 因为数据查询语句逻辑是这样的（发送者不会把刚发送的私信当作是未读私信）：</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;selectLetterUnreadCount&quot; resultType<span class="operator">=</span>&quot;int&quot;<span class="operator">&gt;</span>  </span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">count</span>(id)  </span><br><span class="line">    <span class="keyword">from</span> message  </span><br><span class="line">    <span class="keyword">where</span> status <span class="operator">=</span> <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">and</span> from_id <span class="operator">!=</span> <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">and</span> to_id <span class="operator">=</span> #&#123;userId&#125;  </span><br><span class="line">    <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;conversationId != null&quot;<span class="operator">&gt;</span>  </span><br><span class="line">        <span class="keyword">and</span> conversation_id <span class="operator">=</span> #&#123;conversationId&#125;  </span><br><span class="line">    <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span>  </span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Java项目</category>
      </categories>
      <tags>
        <tag>Java SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>仿牛客论坛项目05-Redis</title>
    <url>/2025/03/11/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE05-Redis/</url>
    <content><![CDATA[<p>仿牛客论坛项目05-Redis</p>
<p>点赞功能、我收到的赞、关注和取消关注、关注列表和粉丝列表、Redis优化</p>
<span id="more"></span>

<h2 id="Redis-入门"><a href="#Redis-入门" class="headerlink" title="Redis 入门"></a>Redis 入门</h2><ul>
<li>NoSQL（not only）：关系型数据库之外的数据库</li>
<li>Redis 是基于键值对的 NoSQL 数据库，key 是 String 类型，值支持多种数据结构：字符串、哈希、列表、集合、有序集合</li>
<li>Redis 将所有数据都存放在内存，读写性能很强；并将内存中的数据以快照或日志的形式保存到硬盘上，保证数据安全性。</li>
<li>典型应用场景：缓存、排行榜、计数器（帖子浏览量）、社交网络（点赞）、消息队列。<br>安装方法：<code>brew install redis</code><br>启动 redis 服务器：<code>redis-server</code><br>连接到 redis 服务器：<code>redis-cli</code></li>
</ul>
<h2 id="Spring-整合-Redis"><a href="#Spring-整合-Redis" class="headerlink" title="Spring 整合 Redis"></a>Spring 整合 Redis</h2><ul>
<li>点赞<ul>
<li>针对帖子、评论点赞</li>
<li>第一次点赞、第二次点赞取消</li>
</ul>
</li>
<li>首页显示点赞数量<ul>
<li>统计帖子点赞数量</li>
</ul>
</li>
<li>详情页显示点赞数量<ul>
<li>统计点赞数量</li>
<li>显示点赞状态<br>  用 redis 提高性能。<br>  直接在业务层，在redis中存数据</li>
</ul>
</li>
</ul>
<h2 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h2><ul>
<li>点赞<ul>
<li>对帖子、评论点赞</li>
<li>第一次点赞、第二次取消点赞</li>
</ul>
</li>
<li>首页点赞数量<ul>
<li>统计帖子点赞数</li>
</ul>
</li>
<li>详情页点赞数量<ul>
<li>统计点赞数量</li>
<li>显示点赞状态<br>  redis中存储格式：<code>like:entity:entityType:entityId -&gt; set(userId)</code><br>  <code>like:user:userId -&gt; int</code></li>
</ul>
</li>
</ul>
<h2 id="我收到的赞"><a href="#我收到的赞" class="headerlink" title="我收到的赞"></a>我收到的赞</h2><p>重构点赞功能</p>
<ul>
<li>以用户为key，记录点赞数量<br>开发个人主页</li>
<li>以用户为key，查询点赞数量<br>点赞业务中加上维护用户收到的赞，一个业务中有两个更新，要用 redis 的事务操作。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">like</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> entityType, <span class="type">int</span> entityId, <span class="type">int</span> entityUserId)</span> &#123;  </span><br><span class="line"><span class="comment">//        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);  </span></span><br><span class="line"><span class="comment">//        System.out.println(entityLikeKey);  </span></span><br><span class="line"><span class="comment">//        // 判断当前用户是否点过赞,userId是否在redis集合里  </span></span><br><span class="line"><span class="comment">//        boolean isMember = redisTemplate.opsForSet().isMember(entityLikeKey, userId);  </span></span><br><span class="line"><span class="comment">//        if (isMember) &#123;  </span></span><br><span class="line"><span class="comment">//            // 如果点过赞，就取消点赞  </span></span><br><span class="line"><span class="comment">//            redisTemplate.opsForSet().remove(entityLikeKey, userId);  </span></span><br><span class="line"><span class="comment">//        &#125; else &#123;  </span></span><br><span class="line"><span class="comment">//            // 如果没点过赞，就点赞  </span></span><br><span class="line"><span class="comment">//            redisTemplate.opsForSet().add(entityLikeKey, userId);  </span></span><br><span class="line"><span class="comment">//        &#125;  </span></span><br><span class="line">        redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">SessionCallback</span>() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(RedisOperations operations)</span> <span class="keyword">throws</span> DataAccessException &#123;  </span><br><span class="line">                <span class="type">String</span> <span class="variable">entityLikeKey</span> <span class="operator">=</span> RedisKeyUtil.getEntityLikeKey(entityType, entityId);  </span><br><span class="line">                <span class="type">String</span> <span class="variable">userLikeKey</span> <span class="operator">=</span> RedisKeyUtil.getUserLikeKey(entityUserId);  </span><br><span class="line">  </span><br><span class="line">                <span class="comment">// 查询不要放在事务里  </span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isMember</span> <span class="operator">=</span> operations.opsForSet().isMember(entityLikeKey, userId);  </span><br><span class="line">  </span><br><span class="line">                operations.multi(); <span class="comment">// 开启事务  </span></span><br><span class="line">                <span class="keyword">if</span> (isMember) &#123;  </span><br><span class="line">                    operations.opsForSet().remove(entityLikeKey, userId);  </span><br><span class="line">                    operations.opsForValue().decrement(userLikeKey);  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    operations.opsForSet().add(entityLikeKey, userId);  </span><br><span class="line">                    operations.opsForValue().increment(userLikeKey);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">return</span> operations.exec();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="关注、取消关注"><a href="#关注、取消关注" class="headerlink" title="关注、取消关注"></a>关注、取消关注</h2><ul>
<li>需求<ul>
<li>实现关注、取消关注</li>
<li>统计用户关注数、粉丝数</li>
</ul>
</li>
<li>关键<ul>
<li>关系：A关注B，A是B的粉丝（follower），B是A的关注目标（followee）</li>
<li>关注的目标可以用用户、帖子、题目，实现时抽象为实体（存在redis）<br>  关注和取消关注是异步请求。（页面不会刷新）<br>  使用redis有序列表zset，新建两个主键：某个用户关注的实体，某个实体拥有的粉丝。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">follow</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> entityType, <span class="type">int</span> entityId)</span> &#123;  </span><br><span class="line">    redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">SessionCallback</span>() &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(RedisOperations operations)</span> <span class="keyword">throws</span> DataAccessException &#123;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">followeeKey</span> <span class="operator">=</span> RedisKeyUtil.getPrefixFolloweeKey(userId, entityType);  </span><br><span class="line">            <span class="type">String</span> <span class="variable">followerKey</span> <span class="operator">=</span> RedisKeyUtil.getPrefixFollowerKey(entityType, entityId);  </span><br><span class="line">  </span><br><span class="line">            operations.multi();  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 某个用户关注的实体  </span></span><br><span class="line">            operations.opsForZSet().add(followeeKey, entityId, System.currentTimeMillis());  </span><br><span class="line">            <span class="comment">// 某个实体拥有的粉丝  </span></span><br><span class="line">            operations.opsForZSet().add(followerKey, userId, System.currentTimeMillis());  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">return</span> operations;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>redis 中存储格式：<code>followee:userId:entityType -&gt; zset(entityId, now)</code><br><code>follower:entityType:entityId -&gt; zset(userId, now)</code></p>
<h2 id="关注列表、粉丝列表"><a href="#关注列表、粉丝列表" class="headerlink" title="关注列表、粉丝列表"></a>关注列表、粉丝列表</h2><ul>
<li>业务层<ul>
<li>查询某个用户关注的人，分页</li>
<li>查询某个用户的粉丝，分页</li>
</ul>
</li>
<li>表现层<ul>
<li>查询关注的人、查询粉丝请求</li>
<li>查询关注的人、查询粉丝模版<br>  查询关注的人，需要分页信息、关注的人列表、当前用户是否关注过这个人<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/followees/&#123;userId&#125;&quot;, method = RequestMethod.GET)</span>  </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getFollowees</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> <span class="type">int</span> userId, Model model, Page page)</span> &#123;  </span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(userId);  </span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;该用户不存在！&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>, user);  </span><br><span class="line">    <span class="comment">//分页信息  </span></span><br><span class="line">    page.setLimit(<span class="number">5</span>);  </span><br><span class="line">    page.setPath(<span class="string">&quot;/followees/&quot;</span> + userId);  </span><br><span class="line">    page.setRows((<span class="type">int</span>) followService.findFolloweeCount(userId, ENTITY_TYPE_USER));  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 关注列表  </span></span><br><span class="line">    List&lt;Map&lt;String,Object&gt;&gt; userList = followService.findFollowees(userId, page.getOffset(), page.getLimit());  </span><br><span class="line">    <span class="keyword">if</span>(userList != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">for</span>(Map&lt;String, Object&gt; map : userList) &#123;  </span><br><span class="line">            <span class="comment">// 判断是否已关注  </span></span><br><span class="line">            <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> (User) map.get(<span class="string">&quot;user&quot;</span>);  </span><br><span class="line">            map.put(<span class="string">&quot;hasFollowed&quot;</span>, hasFollowed(u.getId()));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    model.addAttribute(<span class="string">&quot;users&quot;</span>, userList);  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/site/followee&quot;</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="优化登录模块"><a href="#优化登录模块" class="headerlink" title="优化登录模块"></a>优化登录模块</h2><ul>
<li>使用 Redis 存储验证码<ul>
<li>验证码要频繁访问和刷新，对性能要求高</li>
<li>验证码不需要永久保存，很短时间后失效</li>
<li>目前存在了 session 中，用户量大时，存储大量验证码会占用内容，影响性能；分布式部署时，不同服务器上的 session 无法共享，导致无法验证。</li>
</ul>
</li>
<li>使用 Redis 存储登录凭证<ul>
<li>目前登录凭证存在 Mysql 中，每次登录都要查询用户凭证，访问频率很高</li>
</ul>
</li>
<li>使用 Redis 缓存用户信息<ul>
<li>处理每次请求，都要根据凭证查询用户信息，访问频率高</li>
</ul>
</li>
</ul>
<p><strong>总结适合用 Redis 存储的数据：</strong></p>
<ul>
<li>需要频繁读写，但对一致性要求不高的数据，如：热点数据、排行版、计数器</li>
<li>需要缓存的数据，如用户信息、文章内容</li>
<li>需要短时存储的数据，如验证码</li>
<li>需要实时统计的数据，如点赞数、浏览量、粉丝数<br>Redis 作为缓存 + MySQL 作为持久化存储</li>
</ul>
<ol>
<li><p>验证码使用 redis 存储</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存入redis  </span></span><br><span class="line"><span class="comment">// 验证码的归属，用cookie保存  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">kapthcaOwner</span> <span class="operator">=</span> CommunityUtil.generateUUID();  </span><br><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;kaptchaOwner&quot;</span>, kapthcaOwner);  </span><br><span class="line">cookie.setMaxAge(<span class="number">60</span>);  </span><br><span class="line">cookie.setPath(contextPath);  </span><br><span class="line">response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从redis中取出验证码  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">kaptcha</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line"><span class="keyword">if</span>(StringUtils.isNoneBlank(kaptchaOwner)) &#123;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> RedisKeyUtil.getKaptchaKey(kaptchaOwner);  </span><br><span class="line">    kaptcha = redisTemplate.opsForValue().get(redisKey).toString();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录凭证使用 redis 存储<br>登录时存入，登出时删掉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> RedisKeyUtil.getTicketKey(loginTicket.getTicket());  </span><br><span class="line"><span class="comment">// redis 将对象序列化为JSON格式的字符串  </span></span><br><span class="line">redisTemplate.opsForValue().set(redisKey, loginTicket, expiredSeconds, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logout</span><span class="params">(String ticket)</span> &#123;  </span><br><span class="line">    <span class="comment">// loginTicketMapper.updateStatus(ticket, 1);  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> RedisKeyUtil.getTicketKey(ticket);  </span><br><span class="line">    <span class="comment">// 将对象的status改为1  </span></span><br><span class="line">    <span class="type">LoginTicket</span> <span class="variable">loginTicket</span> <span class="operator">=</span> (LoginTicket) redisTemplate.opsForValue().get(redisKey);  </span><br><span class="line">    loginTicket.setStatus(<span class="number">1</span>);  </span><br><span class="line">    <span class="comment">// 改完再存进去  </span></span><br><span class="line">    redisTemplate.opsForValue().set(redisKey, loginTicket);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 根据ticket查询凭证  </span></span><br><span class="line"><span class="keyword">public</span> LoginTicket <span class="title function_">findLoginTicket</span><span class="params">(String ticket)</span> &#123;  </span><br><span class="line">    <span class="comment">// return loginTicketMapper.selectByTicket(ticket);  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> RedisKeyUtil.getTicketKey(ticket);  </span><br><span class="line">    <span class="keyword">return</span> (LoginTicket) redisTemplate.opsForValue().get(redisKey);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>redis 缓存用户信息<br>调用最多的方法是<code>public User findUserById(int id)</code><br>查询 User 时，先尝试从缓存中取值，能取到就用，取不到就做初始化存入。<br>更改用户信息时，把缓存删除。如果更新缓存，会有并发的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 优先从缓存中取值  </span></span><br><span class="line"><span class="keyword">private</span> User <span class="title function_">getCache</span><span class="params">(<span class="type">int</span> userId)</span> &#123;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> RedisKeyUtil.getUserKey(userId);  </span><br><span class="line">    <span class="keyword">return</span> (User) redisTemplate.opsForValue().get(redisKey);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 2. 取不到时初始化缓存数据  </span></span><br><span class="line"><span class="keyword">private</span> User <span class="title function_">initCache</span><span class="params">(<span class="type">int</span> userId)</span> &#123;  </span><br><span class="line">    <span class="comment">// 从 MySQL 中查到数据  </span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(userId);  </span><br><span class="line">    <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> RedisKeyUtil.getUserKey(userId);  </span><br><span class="line">    redisTemplate.opsForValue().set(redisKey, user, <span class="number">3600</span>, TimeUnit.SECONDS);  </span><br><span class="line">    <span class="keyword">return</span> user;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 3. 数据变更时，清楚缓存数据  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearCache</span><span class="params">(<span class="type">int</span> userId)</span> &#123;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> RedisKeyUtil.getUserKey(userId);  </span><br><span class="line">    redisTemplate.delete(redisKey);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>为什么用 redis<br> 1、Redis是⼀种基于键值对的NoSQL数据库，它⽀持多种数据结构：<br> 字符串（String）、哈希（hashs）、列表（lists）、集合（sets）、有序集合（sorted sets）等<br> 2、Redis将所有的数据都存在内存中，所以它的读写性能⼗分惊⼈。<br> 同时，Redis还可以将内存中的数据以快照或者⽇志的形式保存到硬盘上，以保证数据的安全性。<br> 3、缓存、排⾏榜(热⻔帖⼦)、计数器、社交⽹络(点赞数)、消息队列等。</li>
<li>如何优化登陆模块？<br> 当⽤户点击刷新验证码时，服务端⾸先给当前需要登陆的游客，设置⼀个随机字符串(kaptchaOwner)，⽤于标识当前这个游客，然后将随机字符串存⼊到cookie中，返回给浏览器，然后服务端的 redis 保存 key:随机字符串,接着⽤户输⼊⽤户名，密码，验证码，再次点击登陆时，服务端会从 cookie 中拿到 kaptchaOwner ,通过它可以从 Redis 中得到正确的验证码，然后与⽤户输⼊的验证码做⽐较，看是否⼀致。</li>
</ol>
]]></content>
      <categories>
        <category>Java项目</category>
      </categories>
      <tags>
        <tag>Java SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>仿牛客论坛项目06-Kafka实现系统通知</title>
    <url>/2025/03/13/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE06-Kafka%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5/</url>
    <content><![CDATA[<p>仿牛客论坛项目06-Kafka实现系统通知</p>
<p>阻塞队列、spring整合kafka、发送系统通知、显示系统通知</p>
<span id="more"></span>

<p>解决系统发送通知的功能。</p>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>kafka 是框架，用阻塞队列也能实现，便于理解 kafka</p>
<ul>
<li>BlockingQueue<ul>
<li>解决线程通信问题</li>
<li>阻塞方法：put、take</li>
</ul>
</li>
<li>生产者消费者模式。<ul>
<li>生产者：生产数据的线程</li>
<li>消费者：使用数据的线程</li>
<li>BlockingQueue 避免两个线程直接连接</li>
</ul>
</li>
<li>实现类<ul>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue</li>
</ul>
</li>
</ul>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><ul>
<li>简介<ul>
<li>分布式的流媒体平台</li>
<li>应用：消息系统、日志收集、用户行为追踪、流式处理</li>
</ul>
</li>
<li>特点<ul>
<li>高吞吐量（适合海量数据，如日志）、消息持久化（存到硬盘）、高可靠性（分布式）、高扩展性（便于增加服务器）</li>
</ul>
</li>
<li>术语<ul>
<li>Broker（服务器）、Zookeeper（管理Kafka集群）</li>
<li>Topic（主题）、Partition（对主题的分区，增强并发能力）、Offset（消息在分区中的位置）</li>
<li>Leader Replica（主副本）、Follower Replica（随从副本）<br>  安装命令：<code>brew install kafka</code><br>  启动zookeeper：<code>brew services start zookeeper    </code>zookeeper-server-start &#x2F;opt&#x2F;homebrew&#x2F;etc&#x2F;kafka&#x2F;zookeeper.properties&#96;</li>
</ul>
</li>
</ul>
<p>启动kafka服务：<code>brew services start kafka  </code>kafka-server-start &#x2F;opt&#x2F;homebrew&#x2F;etc&#x2F;kafka&#x2F;server.properties&#96;</p>
<p>停止命令：<code>brew services stop zookeeper</code><br>创建主题：<code>kafka-topics  --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic test 查看主题：</code>kafka-topics –list –bootstrap-server localhost:9092<code> 发布消息（生产者）：</code>kafka-console-producer –broker-list localhost:9092 –topic test<code> 订阅消息（消费者）：</code>kafka-console-consumer –bootstrap-server localhost:9092 –topic test –from-beginning&#96;</p>
<h2 id="Spring-整合-Kafka"><a href="#Spring-整合-Kafka" class="headerlink" title="Spring 整合 Kafka"></a>Spring 整合 Kafka</h2><ul>
<li>引入依赖<ul>
<li>spring-kafka</li>
</ul>
</li>
<li>配置 Kafka<ul>
<li>配置server、consumer</li>
</ul>
</li>
<li>访问 Kafka<ul>
<li>生产者：<code>kafkaTemplate.send(topic, data)</code></li>
<li>消费者：注解<code>@KafkaListener(topics=&#123;&quot;test&quot;&#125;)</code> 修饰方法，得到消息</li>
</ul>
</li>
</ul>
<h2 id="发送系统通知"><a href="#发送系统通知" class="headerlink" title="发送系统通知"></a>发送系统通知</h2><p>发布消息对系统来说很频繁</p>
<ul>
<li>触发事件<br>  评论、点赞、关注后，发布通知<br>  定义三类不同的主题，评论、点赞、关注发生后，生产者放到队列中。<br>  异步，生产者、消费者可以同时处理</li>
<li>处理事件<br>  封装事件对象，开发事件的生产者和消费者</li>
</ul>
<ol>
<li><strong>定义通知消息模型</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Event</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String topic;  </span><br><span class="line">    <span class="comment">// 触发事件的用户  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> userId;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> entityType;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> entityId;  </span><br><span class="line">    <span class="comment">// 实体的作者  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> entityUserId;  </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; data = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>生产者发送通知消息</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventProducer</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate kafkaTemplate;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 处理事件(发送消息)  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fireEvent</span><span class="params">(Event event)</span> &#123;  </span><br><span class="line">        <span class="comment">// 将事件发布到指定的主题  </span></span><br><span class="line">        kafkaTemplate.send(event.getTopic(), JSONObject.toJSONString(event));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>消费者接收通知消息</strong>：消费者订阅相应的 Kafka topic，接收通知消息，并根据消息类型执行相应的通知操作<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@KafkaListener(topics = &#123;TOPIC_COMMENT, TOPIC_LIKE, TOPIC_FOLLOW&#125;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(ConsumerRecord record)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span>(record == <span class="literal">null</span> || record.value() == <span class="literal">null</span>) &#123;  </span><br><span class="line">        logger.error(<span class="string">&quot;消息内容为空!&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">Event</span> <span class="variable">event</span> <span class="operator">=</span> JSONObject.parseObject(record.value().toString(), Event.class);  </span><br><span class="line">    <span class="keyword">if</span>(event == <span class="literal">null</span>) &#123;  </span><br><span class="line">        logger.error(<span class="string">&quot;消息格式错误!&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 发送站内通知(后台统一发送)  </span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();  </span><br><span class="line">    message.setFromId(SYSTEM_USER_ID);  </span><br><span class="line">    message.setToId(event.getEntityUserId());  </span><br><span class="line">    message.setConversationId(event.getTopic());  </span><br><span class="line">    message.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());  </span><br><span class="line">  </span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">    map.put(<span class="string">&quot;userId&quot;</span>, event.getUserId());  </span><br><span class="line">    map.put(<span class="string">&quot;entityType&quot;</span>, event.getEntityType());  </span><br><span class="line">    map.put(<span class="string">&quot;entityId&quot;</span>, event.getEntityId());  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(!event.getData().isEmpty()) &#123;  </span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, Object&gt; entry : event.getData().entrySet()) &#123;  </span><br><span class="line">            map.put(entry.getKey(), entry.getValue());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    message.setContent(JSONObject.toJSONString(map));  </span><br><span class="line">    messageService.addMessage(message);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="显示系统通知"><a href="#显示系统通知" class="headerlink" title="显示系统通知"></a>显示系统通知</h2><ul>
<li>通知列表<ul>
<li>显示评论、点赞、关注三种类型的通知</li>
</ul>
</li>
<li>通知详情<ul>
<li>分页显示某一类主题的通知</li>
</ul>
</li>
<li>唯独消息<ul>
<li>页面头部显示未读消息数（用拦截器实现，每个页面上都有）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在模板渲染之前，将未读消息的数量传递给模板</span></span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> hostHolder.getUser();  </span><br><span class="line">    <span class="keyword">if</span>(user != <span class="literal">null</span> &amp;&amp; modelAndView != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">letterUnreadCount</span> <span class="operator">=</span> messageService.findLetterUnreadCount(user.getId(), <span class="literal">null</span>);  </span><br><span class="line">        <span class="type">int</span> <span class="variable">noticeUnreadCount</span> <span class="operator">=</span> messageService.findNoticeUnreadCount(user.getId(), <span class="literal">null</span>);  </span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;allUnreadCount&quot;</span>, letterUnreadCount + noticeUnreadCount);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>视频代码里有不严谨的地方：<br>查询某一类消息的通知，当页面某一类消息为空的时候，页面会报错<br>原来模版里写的 <code>th:if=&quot;$&#123;followNotice.message != null&#125;&quot;</code> 这样当followNotice为空，就获取不到这个属性了<br><code>th:if=&quot;$&#123;followNotice != null and followNotice.message != null&#125;&quot;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询点赞类的通知</span></span><br><span class="line">       message = messageService.findLatestNotice(user.getId(), TOPIC_LIKE);</span><br><span class="line">       messageVO = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span>(message != <span class="literal">null</span>) &#123;</span><br><span class="line">           messageVO.put(<span class="string">&quot;message&quot;</span>, message);</span><br><span class="line">           <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> HtmlUtils.htmlUnescape(message.getContent());</span><br><span class="line">           <span class="comment">// &#123;&amp;quot;entityType&amp;quot;:1,&amp;quot;entityId&amp;quot;:234,&amp;quot;postId&amp;quot;:234,&amp;quot;userId&amp;quot;:156&#125;</span></span><br><span class="line">           Map&lt;String, Object&gt; data = JSONObject.parseObject(content, HashMap.class);</span><br><span class="line">           messageVO.put(<span class="string">&quot;user&quot;</span>, userService.findUserById((Integer) data.get(<span class="string">&quot;userId&quot;</span>)));</span><br><span class="line">           messageVO.put(<span class="string">&quot;entityType&quot;</span>, data.get(<span class="string">&quot;entityType&quot;</span>));</span><br><span class="line">           messageVO.put(<span class="string">&quot;entityId&quot;</span>, data.get(<span class="string">&quot;entityId&quot;</span>));</span><br><span class="line">           messageVO.put(<span class="string">&quot;postId&quot;</span>, data.get(<span class="string">&quot;postId&quot;</span>));</span><br><span class="line">           <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> messageService.findNoticeCount(user.getId(), TOPIC_LIKE);</span><br><span class="line">           messageVO.put(<span class="string">&quot;count&quot;</span>, count);</span><br><span class="line">           <span class="type">int</span> <span class="variable">unread</span> <span class="operator">=</span> messageService.findNoticeUnreadCount(user.getId(), TOPIC_LIKE);</span><br><span class="line"></span><br><span class="line">           messageVO.put(<span class="string">&quot;unread&quot;</span>, unread);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">// 当页面某一类消息为空的时候，页面会报错</span></span><br><span class="line">       model.addAttribute(<span class="string">&quot;likeNotice&quot;</span>, messageVO); </span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p>为什么系统发送通知要用 Kafka 实现<br> 需求：有大量用户操作时，触发大量的通知需求，造成传统数据库负载较高<br> Kafka：而Kafka支持每秒处理数百万条数据，有效处理高并发的通知需求</p>
</li>
<li><p>系统发送通知（评论、点赞、关注）如何用 Kafka 实现的</p>
<ol>
<li><strong>定义通知消息模型</strong>：封装通知的相关数据（如用户ID、实体类型、消息内容等）。</li>
<li><strong>生产者发送通知消息</strong>：用户进行点赞、评论或关注时，将事件封装成消息发送到 Kafka。</li>
<li><strong>消费者接收通知消息</strong>：消费者订阅相应的 Kafka topic，接收通知消息，并根据消息类型执行相应的通知操作。</li>
<li><strong>通知服务处理通知</strong>：根据消息内容发送通知（如站内信、邮件、短信、推送等）。</li>
</ol>
</li>
<li><p>消费者接收通知消息时，最后还会把消息放到数据库里，在高并发的情况下，数据库的写入操作依然会成为性能瓶颈<br> 可能的解决方法：消息队列+缓存+异步写入数据库</p>
<ol>
<li>消费者将消息先存储到 <strong>Redis</strong> 缓存中；</li>
<li>异步的线程批量将 Redis 中的消息写入数据库。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Java项目</category>
      </categories>
      <tags>
        <tag>Java SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>20250313携程笔试题练习</title>
    <url>/2025/03/14/%E7%AE%97%E6%B3%95%E9%A2%98/20250313%E6%90%BA%E7%A8%8B%E7%AC%94%E8%AF%95%E9%A2%98%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p>做题地址：<a href="https://oj.niumacode.com/training/41/problems">https://oj.niumacode.com/training/41/problems</a></p>
<span id="more"></span>

<h2 id="20250313-1-诗"><a href="#20250313-1-诗" class="headerlink" title="20250313_1_诗"></a>20250313_1_诗</h2><p>签到题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1000</span>; i ++ ) &#123;</span><br><span class="line">        ans += s[j];</span><br><span class="line">        <span class="keyword">if</span>(j + i &lt; n) &#123;</span><br><span class="line">            j += i;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20250313-2-游游的数组染色"><a href="#20250313-2-游游的数组染色" class="headerlink" title="20250313_2_游游的数组染色"></a>20250313_2_游游的数组染色</h2><p>排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T --) &#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, a[i] + n - i);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20250313-3-小牛的数组询问"><a href="#20250313-3-小牛的数组询问" class="headerlink" title="20250313_3_小牛的数组询问"></a>20250313_3_小牛的数组询问</h2><p>计算质因子、滑动窗口求长度为k最小的子数组和<br><strong>计算质因子：</strong><br>计算整数x能被多少个质数整除<br>通过逐步除尽x的因子，来计算质因子的个数。12&#x3D;2^2+3</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= x; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            sum ++;</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>) &#123;</span><br><span class="line">                x /= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) sum++;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= x; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            sum ++;</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>) &#123;</span><br><span class="line">                x /= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) sum++;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i] = <span class="built_in">calc</span>(a[i]);</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mink = INT_MAX;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; n) &#123;</span><br><span class="line">       	cnt += a[r];</span><br><span class="line">        <span class="keyword">if</span>(r - l + <span class="number">1</span> == k) &#123;</span><br><span class="line">            mink = <span class="built_in">min</span>(mink, cnt);</span><br><span class="line">            cnt -= a[l];</span><br><span class="line">            l ++;</span><br><span class="line">        &#125;</span><br><span class="line">        r ++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum - mink &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20250313-4-偶数路径2-0"><a href="#20250313-4-偶数路径2-0" class="headerlink" title="20250313_4_偶数路径2.0"></a>20250313_4_偶数路径2.0</h2><p>还没做出来，样例通过了，提交通过一个样例<br>建图，dfs遍历整棵树<br>结论：一组数中包含奇数，那么这组数gcd不可能是偶数；如果一组数全是偶数，那么这组数gcd是偶数。</p>
]]></content>
      <categories>
        <category>笔试题</category>
      </categories>
  </entry>
  <entry>
    <title>20250313百度笔试题练习</title>
    <url>/2025/03/15/%E7%AE%97%E6%B3%95%E9%A2%98/20250313%E7%99%BE%E5%BA%A6%E7%AC%94%E8%AF%95%E9%A2%98%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p>做题地址：<a href="https://oj.niumacode.com/training/42">https://oj.niumacode.com/training/42</a></p>
<span id="more"></span>

<h2 id="20250313-1-数组删除"><a href="#20250313-1-数组删除" class="headerlink" title="20250313_1_数组删除"></a>20250313_1_数组删除</h2><p>签到题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T -- ) &#123;</span><br><span class="line">        <span class="type">int</span> n, l , r;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; h;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            h[a[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(h[a[i]] &gt;= l &amp;&amp; h[a[i]] &lt;= r) <span class="keyword">continue</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : ans) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, v);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20250313-2-最大的和"><a href="#20250313-2-最大的和" class="headerlink" title="20250313_2_最大的和"></a>20250313_2_最大的和</h2><p>贪心，异或的性质<br>虽然题目说的是每次异或相邻两个数，但是由于异或的性质，对一个数异或偶数次还是这个数本身，因此可以每次异或任意两个数。<br>记录每个数异或后的变化值，优先异或两个对数组之和增加大的，因此要从大到小排序。<br><img src="/2025/03/15/%E7%AE%97%E6%B3%95%E9%A2%98/20250313%E7%99%BE%E5%BA%A6%E7%AC%94%E8%AF%95%E9%A2%98%E7%BB%83%E4%B9%A0/1.png" alt="1"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">   	<span class="keyword">while</span>(T -- ) &#123;</span><br><span class="line">        <span class="type">int</span> n, x;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            sum += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; gain;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">            gain.<span class="built_in">push_back</span>((a[i] ^ x) - a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(gain.<span class="built_in">rbegin</span>(), gain.<span class="built_in">rend</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; gain.<span class="built_in">size</span>() - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(gain[i] + gain[i + <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sum += gain[i] + gain[i + <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔试题</category>
      </categories>
  </entry>
  <entry>
    <title>美的20250317笔试</title>
    <url>/2025/03/19/%E7%AC%94%E8%AF%95%E9%A2%98/%E7%BE%8E%E7%9A%8420250317%E7%AC%94%E8%AF%95/</url>
    <content><![CDATA[<p>两个算法题限制Java语法，虽然简单，但不熟</p>
<span id="more"></span>

<h1 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h1><ol>
<li>线程同步关键字<br> <code>synchronized</code>、<code>volatile</code>、<code>ReentrantLock</code>等</li>
<li>快排思想<br> 快速排序的基本思想是通过选择一个“基准”元素，将数组分为两部分，使得一部分的所有元素都小于基准，另一部分的所有元素都大于基准，然后递归地对这两部分进行排序。</li>
<li>sleep() 和 wait() 区别<br> <code>sleep()</code><ul>
<li>定义：<code>sleep()</code>是<code>Thread</code>类的一个静态方法。</li>
<li>功能：它使当前正在执行的线程暂停执行指定的时间（以毫秒为单位），期间该线程不会释放任何锁，也就是说，如果一个线程调用了<code>sleep()</code>方法，它仍然持有之前获取的所有锁。</li>
<li>使用场景：当你希望线程暂时停止执行一段时间，而不涉及线程间的协作时可以使用<code>sleep()</code>。例如，在模拟延迟或定时任务中。<br> <code>wait()</code>：</li>
<li>定义：<code>wait()</code>是<code>Object</code>类的一个实例方法。</li>
<li>功能：它必须与同步块或同步方法一起使用，并且会释放当前对象的锁。当一个线程调用某个对象的<code>wait()</code>方法时，这个线程会被加入到该对象的等待队列中并进入等待状态，直到另一个线程调用同一个对象的<code>notify()</code>或<code>notifyAll()</code>方法来唤醒它。</li>
<li>使用场景：主要用于线程之间的协作，比如生产者-消费者问题中，用来协调多个线程对共享资源的访问。</li>
</ul>
</li>
<li>数组和链表区别<br> 数组静态分配内存、链表动态分配内存，数组和链表都分配在堆区</li>
<li>代码运行结果<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>;  </span><br><span class="line">    System.out.println(<span class="string">&quot;value值为：&quot;</span> + (i &gt; <span class="number">4</span> ? <span class="number">99.9</span> : <span class="number">9</span>));  <span class="comment">// 输出: value值为：9.0  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>事务ACID性质</li>
<li>存储引擎<ol>
<li>InnoDB用自适应哈希索引（Adaptive Hash Index, AHI）加速</li>
</ol>
</li>
<li>数据库可重复读特点<br> 只有幻读问题</li>
<li>数据库默认隔离级别<br> 可重复读</li>
<li>线性链表特点<br>元素在逻辑上顺序，在物理存储上，不是顺序的</li>
</ol>
<h1 id="不定向"><a href="#不定向" class="headerlink" title="不定向"></a>不定向</h1><ol>
<li>Redis 惰性删除+定期删除</li>
<li>垃圾回收机制特点</li>
<li>OS内存管理：段表、页表</li>
<li>List 的 Iterator，打印元素<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">	System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>垃圾回收策略<br> CMS收集器是老年代的收集器</li>
</ol>
<h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h1><ol>
<li>不限语言，核心代码模式</li>
<li>限制Java，核心代码模式</li>
<li>限制Java，ACM模式</li>
</ol>
]]></content>
      <categories>
        <category>笔试题</category>
      </categories>
  </entry>
  <entry>
    <title>作业帮20250319笔试</title>
    <url>/2025/03/19/%E7%AC%94%E8%AF%95%E9%A2%98/%E4%BD%9C%E4%B8%9A%E5%B8%AE20250319%E7%AC%94%E8%AF%95/</url>
    <content><![CDATA[<p>算法题写出两个</p>
<span id="more"></span>

<h1 id="单选（48分）"><a href="#单选（48分）" class="headerlink" title="单选（48分）"></a>单选（48分）</h1><ol>
<li>二进制基础</li>
<li>Linux中显示系统运行状态的命令<br> top：实时显示系统的进程和资源使用情况。<br> ps：显示当前进程的状态。</li>
<li>数据库索引<br> 数据索引主要是为了提高查询效率，而不是插入效率。</li>
<li>计算机网络：用什么技术防止A反悔发送过的数据<br> 数字签名是一种基于公钥密码学的技术，可以确保消息的完整性和不可否认性。</li>
<li>MySQL语句：查询B中和A表不匹配的所有行<br> <code>SELECT * FROM B b LEFT JOIN A a ON b.id = a.id WHERE a.id IS NULL;</code><br> 左外连接，它返回左表（在这个例子中是B表）中的所有记录，以及右表（A表）中与之匹配的记录。如果左表中的某条记录在右表中没有匹配项，则结果集中对应右表的字段将为<code>NULL</code></li>
<li>链表第i个元素后插入一个元素，要向后移动0个</li>
<li>POST 和 GET 的主要区别<br> POST 不通过 URL 传数据</li>
<li>数据库操作<br> “差集”（Difference），即从一个集合中移除另一个集合中存在的元素。</li>
<li>不正确的语句</li>
<li>MVC模式<br><strong>Model（模型）</strong> 负责管理应用程序的数据、定义数据结构以及执行与数据相关的操作和业务逻辑。<br><strong>View（视图）</strong> 负责呈现数据给用户，并接收用户的输入。<br><strong>Controller（控制器）</strong> 作为Model和View之间的中介，处理用户输入并更新Model或View。</li>
<li>执行系统调用的步骤<br>传递系统调用参数、执行陷阱（Trap）指令、内核处理系统调用、返回用户态</li>
<li>根据二叉树的前序遍历和中序遍历写出二叉树</li>
<li>单例模式</li>
<li>循环语句执行次数</li>
<li>进程通信最快方式<br>共享内存</li>
<li>数据库，T1有S锁，T2申请X锁会怎么样<br>T2被阻塞，直到T1释放S锁</li>
</ol>
<h1 id="不定项（12分）"><a href="#不定项（12分）" class="headerlink" title="不定项（12分）"></a>不定项（12分）</h1><ol>
<li>OS中什么算法会导致Belady<br> belady现象是指局部置换算法中，发现某进程缺页率变高，于是操作系统给它又分了几个物理页，原以为缺页率的增高是由于工作集变大，物理页帧不够用，结果增加了物理页以后，缺页率不降反。<br> belady现象的出现，是由于置换算法+将需要经常访问的页面置换了出去导致的。例如FIFO算法，即便最开始进入内存的那个页面是最近以及未来要经常访问的，但是FIFO还是选择把它换出去。</li>
<li>多线程编程<br> Java会自动管理内存泄漏</li>
<li>OS一段代码，问进程会出现饥饿吗</li>
<li>浅复制和深复制<br> •浅拷贝是指只复制对象本身和其内部的值类型字段，但不会复制对象内部的引用类型字段。浅拷贝只是创建一个新的对象，然后将原对象的字段值复制到新对象中，但如果原对象内部有引用类型的字段，只是将引用复制到新对象中，两个对象指向的是同一个引用对象。<br> • 深拷贝是指在复制对象的同时，将对象内部的所有引用类型字段的内容也复制一份，而不是共享引用。深拷贝会递归复制对象内部所有引用类型的字段，生成一个全新的对象以及其内部的所有对象。</li>
</ol>
<h1 id="算法题（40分）"><a href="#算法题（40分）" class="headerlink" title="算法题（40分）"></a>算法题（40分）</h1><ol>
<li>输入一个 url 和 key 字符串，输出key对应的value</li>
<li>输入一些数，求乘积最大的三个数。注意输入数字之间有逗号</li>
<li>小美的彩带（太困，题都看不懂）<a href="https://www.nowcoder.com/questionTerminal/5cf15987d8654d69b67e46fb25fe051b?page=1&onlyReference=false">https://www.nowcoder.com/questionTerminal/5cf15987d8654d69b67e46fb25fe051b?page=1&amp;onlyReference=false</a></li>
</ol>
]]></content>
      <categories>
        <category>笔试题</category>
      </categories>
  </entry>
  <entry>
    <title>美的20250320暑期实习AI面</title>
    <url>/2025/03/20/%E9%9D%A2%E7%BB%8F/%E7%BE%8E%E7%9A%8420250320%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0AI%E9%9D%A2/</url>
    <content><![CDATA[<p>没八股，基本没技术，像hr面。</p>
<p>发现豆包很好用，可以用语音通话进行模拟面试，多多练习！</p>
<span id="more"></span>

<ol>
<li>看到您获得了xxx比赛，请说明问，您为什么想要获得它？为此您做了哪些努力？</li>
<li>团队组建到项目实施，再到最终获得一等奖，你展现了不错的团队合作能力和创新精神，请问在这个项目中你个人有什么特别的收获？面对未来，你有没有考虑过进一步优化或改进这个项目或某个部分？</li>
<li>Springboot 的社交论坛系统项目中，您是如何制定项目计划、分配资源和确保任务按计划执行的？描述您在项目管理中所采取的关键步骤和决策。</li>
<li>注意到你提到了项目各个阶段需要分工和计划执行，以及如何确保进度和解决方案的讨论，但我想了解一下在这个过程中，你具体采取了哪些行动来实现这些目标和任务的分配。</li>
<li>遇到了哪些问题？你是如何与他人进行沟通的？最终结果如何？分享在基于 spring boot 的社交论坛项目中和团队成员通过沟通解决问题的经历，当时遇到了哪些问题？是如何和他人沟通的？最终结果如何？</li>
<li>针对上一个问题，请详细说说在这个过程中，您个人具体采取的行动是什么？</li>
<li>在基于 spring boot 的社交论坛系统中，是如何打破常规，采用新方法解决问题的？请描述如何实施这个方案，以及这个方案的独特之处。</li>
<li>针对上个问题，可以再展开讲讲以上过程中采取行动的细节吗？</li>
<li>why do you want to apply this position? What is your aspiration in 3 years? Please answer in English.</li>
<li>有一张图片是一个人捂着耳朵，然后很多人给他看手表时间，手机时间的，然后他看起来很焦虑，然后问题是 what do you think is the situation？why does this picture remind you of any moment in your life? please share in detail.</li>
<li>7道算术题，找规律、计算题等</li>
<li>15道性格测试</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
  </entry>
  <entry>
    <title>众安保险20250327笔试</title>
    <url>/2025/03/28/%E7%AC%94%E8%AF%95%E9%A2%98/%E4%BC%97%E5%AE%89%E4%BF%9D%E9%99%A920250327%E7%AC%94%E8%AF%95/</url>
    <content><![CDATA[<p>单选25题，编程2题，开一个摄像头，手机监控。</p>
<span id="more"></span>

<h1 id="单选题"><a href="#单选题" class="headerlink" title="单选题"></a>单选题</h1><ol>
<li>后缀表达式求最大值<br> 7 3 8 2 3 x - 6 5 -  符号 符号 +<br> 两个符号处填什么符号，求表达式最大可能的值</li>
<li>Java集合<br> <code>isEmpty()</code> 和 <code>size==0</code>等价吗<br> <code>Array.asList()</code> 传入数组<code>int[]</code>作为参数，调用get方法，会有indexoutofbound错误吗<br> <code>foreach</code> 中可以使用 <code>remove/add</code>方法吗<br> <code>toMap</code>的value可以为null吗</li>
<li>设计模式，哪种设计模式是数据驱动的<br> 策略模式，根据数据选择不同的策略</li>
<li>递归算法的时间复杂度<br> f() {<br> for()<br>     for()<br> f(l, mid)<br> f(mid + 1, r)<br> }</li>
<li>操作系统：5GB磁盘，簇大小为2kb，用位图法管理空闲空间，存放位图的簇需要多个簇<ol>
<li>计算磁盘的总簇数<br> 磁盘总大小 &#x3D; 5 GB &#x3D; 5 × 1024 × 1024 KB &#x3D; 5,242,880 KB<br> 簇大小 &#x3D; 2 KB<br> 总簇数 &#x3D; 磁盘总大小 &#x2F; 簇大小 &#x3D; 5,242,880 KB &#x2F; 2 KB &#x3D; 2,621,440 个簇</li>
<li>计算位图的大小<br> 位图法使用 1 bit 表示 1 个簇 的状态（0 &#x3D; 空闲，1 &#x3D; 已占用）。<br> 位图需要的总 bit 数 &#x3D; 总簇数 &#x3D; 2,621,440 bits<br> 转换为字节（Byte）：<br> 1 Byte &#x3D; 8 bits<br> 位图大小（Bytes）&#x3D; 2,621,440 bits &#x2F; 8 &#x3D; 327,680 Bytes</li>
<li>计算位图占用的簇数<br> 簇大小 &#x3D; 2 KB &#x3D; 2 × 1024 Bytes &#x3D; 2048 Bytes<br> 位图占用的簇数 &#x3D; 位图大小 &#x2F; 簇大小 &#x3D; 327,680 Bytes &#x2F; 2048 Bytes ≈ 160 个簇</li>
</ol>
</li>
<li>哪个不是Java的标识符（变量名、方法名、类名） a3x  default string $123<br> default是关键字，不能作为标识符</li>
<li>java类加载机制，选项和父类加载器有关，采用继承方式复用父类加载器吗（错误）<br> 双亲委派模型（Parent Delegation Model）<ul>
<li>Java 类加载器采用 组合（Composition） 而非 继承（Inheritance） 的方式复用父类加载器。</li>
<li>每个类加载器（除 Bootstrap 外）都有一个 父类加载器（Parent ClassLoader），但这是通过 内部引用 实现的，而不是继承关系。</li>
<li>类加载时，子加载器会先委托父加载器加载，父加载器无法完成时才会自己加载。</li>
</ul>
</li>
<li>链栈Stack，栈顶指针为P，节点S，<br>S-&gt;next&#x3D;P P&#x3D;S 是什么操作，是<strong>链栈的入栈（Push）操作</strong></li>
<li>基数排序<br> 基数排序是一种 <strong>非比较型整数排序算法</strong>，其核心思想是 <strong>按位分配和收集</strong>，从最低位（LSD，Least Significant Digit）或最高位（MSD）开始逐位排序。<br> 按最低位（个位）排序：<ul>
<li>将所有数字根据个位数字分配到 0~9 的桶中。</li>
<li>按桶顺序（0→9）依次收集，形成第一次排序结果。</li>
</ul>
</li>
<li>SQL 隔离级别 InnoDB 默认是可重复读</li>
<li>批处理操作系统的特点<br>成批处理、脱机、多道<br>不是特点：多路属于分时系统的核心特点</li>
<li>电报交换、报文交换、分组交换时延排序<br><strong>电报交换 &gt; 报文交换 &gt; 分组交换</strong><ul>
<li><strong>报文交换</strong>介于两者之间，但因效率低下已被分组交换取代。</li>
<li><strong>最低时延</strong>：分组交换（现代网络首选）。</li>
<li><strong>最高时延</strong>：电报交换（因连接建立和独占性）。</li>
</ul>
</li>
<li>Java I&#x2F;O 流用哪种设计模式<br>主要采用了 装饰器模式（Decorator Pattern），同时结合了 适配器模式（Adapter Pattern） 和 工厂模式（Factory Pattern） 的部分思想。<br>装饰器模式：在不修改原有类的基础上，通过嵌套包装（装饰）来添加新功能。</li>
<li>P&#x2F;V 信号量实现互斥初始值设置为1</li>
<li>Redis 端口号、默认数据库、数据库默认数量、daemonize是守护进程吗<br>端口号6379。默认数据库是0  数据库默认数量是16。daemonize是守护进程</li>
<li>完全二叉树 第五层6个节点，根节点是第一层，叶子结点数最少多少个</li>
<li>递归求最大公约数（线段树思想），填代码</li>
<li>分组交换<br>分组交换三种方式：数据报、存储转发、虚电路<br><strong>数据报</strong>可能出现失序、丢失、重复<br><strong>存储转发</strong> 限制发送数据大小，分组不能超过最大传输单元<br><strong>虚电路</strong> 通信前建立逻辑路径（虚电路），传输后释放。</li>
<li>SpringBoot 两个类区别<br><code>@Import</code> 修饰类，通常和 <code>@Configuration</code> 一起使用<br><code>@ImportResource</code> 修饰类，加载方式是xml文件</li>
<li>求子串个数</li>
<li>Linux 看文件节点信息的命令 ls -i</li>
<li>Zookeeper 什么情况下会重新选举 leader<br>当 Leader 出现故障或集群状态变化时，会触发 <strong>Leader 重新选举</strong></li>
<li>Mysql 求select结果<br><code>select count(*) from t where not exist (select * from t where id &gt;= 1002)</code><ul>
<li>如果 **表 <code>t</code> 中至少有一行 <code>id &gt;= 1002</code>**，则 <code>EXISTS</code> 返回 <code>TRUE</code>，<code>NOT EXISTS</code> 返回 <code>FALSE</code>，最终 <code>COUNT(*)</code> 结果为 <strong>0</strong>。</li>
<li>如果 **表 <code>t</code> 中没有任何行 <code>id &gt;= 1002</code>**，则 <code>NOT EXISTS</code> 返回 <code>TRUE</code>，最终 <code>COUNT(*)</code> 结果为 <strong>表 <code>t</code> 的总行数</strong>。</li>
</ul>
</li>
<li>🌟（别的笔试题里做过一次）sleep() 和 wait() 区别<br><code>sleep()</code> 不释放锁<ul>
<li>定义：<code>sleep()</code>是<code>Thread</code>类的一个静态方法。</li>
<li>功能：它使当前正在执行的线程暂停执行指定的时间（以毫秒为单位），期间该线程不会释放任何锁，也就是说，如果一个线程调用了<code>sleep()</code>方法，它仍然持有之前获取的所有锁。</li>
<li>使用场景：当你希望线程暂时停止执行一段时间，而不涉及线程间的协作时可以使用<code>sleep()</code>。例如，在模拟延迟或定时任务中。<br><code>wait()</code> 释放锁：</li>
<li>定义：<code>wait()</code>是<code>Object</code>类的一个实例方法。</li>
<li>功能：它必须与同步块或同步方法一起使用，并且会释放当前对象的锁。当一个线程调用某个对象的<code>wait()</code>方法时，这个线程会被加入到该对象的等待队列中并进入等待状态，直到另一个线程调用同一个对象的<code>notify()</code>或<code>notifyAll()</code>方法来唤醒它。</li>
<li>使用场景：主要用于线程之间的协作，比如生产者-消费者问题中，用来协调多个线程对共享资源的访问。</li>
</ul>
</li>
<li>递增有序表求平均查找长度，l1是平均查找成功长度，l2是平均查找不成功长度，求l1-l2<br>l1 &#x3D; (1 + 2 + … + n) &#x2F; n &#x3D; (n + 1) &#x2F; 2;<br>l2 &#x3D; (1 + 2 + .. + n + n) &#x2F; (n + 1) &#x3D; n&#x2F;2 + n &#x2F; (n + 1);</li>
</ol>
<h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h1><p>简单，都做出来了</p>
<ol>
<li>给定n个数据，每个数据是坐标位置和走的方向，每个人可以向左走和向右走，速度都一样，求多少人会相遇</li>
<li>有一个nxn的矩形，每次操作能给一个数加一，求最少操作多少次，使矩阵旋转90度、180度、270度都是一样的</li>
</ol>
<h1 id="选择题17递归求最大公约数（线段树思想）"><a href="#选择题17递归求最大公约数（线段树思想）" class="headerlink" title="选择题17递归求最大公约数（线段树思想）"></a>选择题17递归求最大公约数（线段树思想）</h1><p>线段树是一种<strong>二叉树数据结构</strong>，用于高效解决<strong>区间查询问题</strong>（如求区间和、最大值、最小值、GCD等）。</p>
<ul>
<li><strong>每个节点</strong>代表一个<strong>区间</strong>的信息（如 <code>[l, r]</code> 的 GCD）。</li>
<li><strong>叶子节点</strong>存储<strong>单个元素</strong>的值。</li>
<li><strong>非叶子节点</strong>存储<strong>子区间合并后的信息</strong>（如左右子树的 GCD）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr;      <span class="comment">// 输入数组</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; tree;     <span class="comment">// 线段树</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 GCD（注意处理 0 的情况）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归构建线段树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[node] = arr[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">2</span> * node, l, mid);          <span class="comment">// 左子树</span></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">2</span> * node + <span class="number">1</span>, mid + <span class="number">1</span>, r);   <span class="comment">// 右子树</span></span><br><span class="line">    tree[node] = <span class="built_in">gcd</span>(tree[<span class="number">2</span> * node], tree[<span class="number">2</span> * node + <span class="number">1</span>]);  <span class="comment">// 合并 GCD</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归查询区间 [ql, qr] 的 GCD</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前区间与查询区间无交集</span></span><br><span class="line">    <span class="keyword">if</span> (qr &lt; l || ql &gt; r) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 中性值（gcd(x, 0) = x）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前区间完全包含在查询区间内</span></span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;</span><br><span class="line">        <span class="keyword">return</span> tree[node];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 根据查询区间与 mid 的关系，决定递归方向</span></span><br><span class="line">    <span class="keyword">if</span> (qr &lt;= mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">2</span> * node, l, mid, ql, qr);  <span class="comment">// 只需查左子树</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ql &gt; mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">2</span> * node + <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr);  <span class="comment">// 只需查右子树</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 查询区间横跨 mid，需合并左右子树的结果</span></span><br><span class="line">        <span class="type">int</span> left_gcd = <span class="built_in">query</span>(<span class="number">2</span> * node, l, mid, ql, mid);</span><br><span class="line">        <span class="type">int</span> right_gcd = <span class="built_in">query</span>(<span class="number">2</span> * node + <span class="number">1</span>, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, qr);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(left_gcd, right_gcd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化线段树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    tree.<span class="built_in">resize</span>(<span class="number">4</span> * n);  <span class="comment">// 线段树大小为 4n</span></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);  <span class="comment">// 根节点从 1 开始</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔试题</category>
      </categories>
  </entry>
  <entry>
    <title>腾讯CDG金融科技后台开发一面凉经</title>
    <url>/2025/04/16/%E9%9D%A2%E7%BB%8F/%E8%85%BE%E8%AE%AFCDG%E9%87%91%E8%9E%8D%E7%A7%91%E6%8A%80%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E4%B8%80%E9%9D%A2%E5%87%89%E7%BB%8F/</url>
    <content><![CDATA[<p>当天做完测评没多久就打电话约面试了。</p>
<p>0416第一次面试30min<br>根据简历上写的技术栈一个一个问的，也不问项目（问项目有没有上线，没上线），也没手撕</p>
<span id="more"></span>

<p>自我介绍</p>
<ol>
<li><p><strong>数组和链表的区别，使用场景</strong><br> 底层存储、查询效率、头插效率、扩容、场景（数组频繁访问、链表插入删除频繁）</p>
</li>
<li><p><strong>树和图的区别</strong><br> 树：一种层次结构的数据结构，由根节点和子节点组成，常用于表示分层关系。<br> 图：由顶点和边组成的数据结构，用于表示对象之间的关系，可以是有向图或无向图。</p>
</li>
<li><p><strong>深度优先搜索和广度优先搜索的区别，为什么要用dfs和bfs</strong><br> DFS：从起点出发，沿一条路径尽可能深入（纵向搜索），直到无法继续再回溯。场景：找出所有路径<br> BFS：按层次逐层扩展（横向搜索），先访问所有相邻节点再深入下一层。使用<strong>队列</strong>实现。场景：最短路、层序遍历</p>
</li>
<li><p><strong>三次握手，发送的内容里面都有什么</strong></p>
</li>
<li><p><strong>第三次握手丢了，客户端直接发送数据了，服务端会怎么样</strong><br> 服务端进行超时重传，直到用完重传次数。<br> 客户端发送的数据包ACK为1，就视为对第二次握手的确认，建立连接并处理数据。<br> 若数据包未携带ACK标志位，服务端因处于<code>SYN_RECV</code>状态，会回复<code>RST</code>（复位）包强制关闭连接。</p>
</li>
<li><p><strong>第三次握手的目的是什么</strong><br> 客户端通过发送ACK包（第三次握手），明确告知服务器已收到其SYN+ACK报文（第二次握手），完成双向通信能力的验证</p>
</li>
<li><p><strong>序列号怎么生成的，从0开始吗</strong><br> TCP连接的初始序列号是一个<strong>随机生成的32位整数</strong>，数据传输时，每个字节按顺序编号，序列号按发送的字节数递增。<br> 固定从0开始易被攻击者预测序列号，伪造数据包（如SYN洪泛攻击）。</p>
</li>
<li><p><strong>TCP数据包里包含哪些，有ACK字段吗，这个ACK和三次握手的有什么不一样</strong><br> 源端口和目标端口、序列号、确认号、控制标志位</p>
</li>
<li><p><strong>HTTP 和 HTTPS 的区别</strong><br> 安全性、端口号不同、握手不同</p>
</li>
<li><p><strong>HTTPS 四次握手过程，每次握手发了什么</strong></p>
</li>
<li><p><strong>发送的数字证书为什么是可靠的，客户端怎么判断是可靠的</strong><br> 客户端依赖内置的根CA公钥验证签名链，确保证书由可信机构签发且内容完整</p>
<p> <a href="https://javabetter.cn/sidebar/sanfene/network.html#_21-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%80%8E%E4%B9%88%E5%8E%BB%E6%A0%A1%E9%AA%8C%E8%AF%81%E4%B9%A6%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7">_21-客户端怎么去校验证书的合法性</a></p>
</li>
<li><p><strong>linux常见命令</strong></p>
</li>
<li><p><strong>linux文件系统了解吗</strong></p>
</li>
<li><p><strong>vim打开一个文件的原理</strong><br> 系统启动 Vim 进程，将文件名作为参数传递<br> 加载 <code>.vimrc</code> 配置文件，初始化命令映射表<br> <code>vim</code>打开文件是将文件内容加载到内存缓冲区供用户编辑，编辑操作作用于缓冲区，保存时再将缓冲区内容写回磁盘文件。</p>
</li>
<li><p><strong>数据库存储引擎有哪些</strong></p>
</li>
<li><p><strong>InnoDB存储引擎和Mysql的区别</strong><br> MySQL 包含存储引擎。<br> MySQL等数据库管理系统（DBMS）是一个完整的软件系统，负责SQL解析、连接管理、查询优化、事务控制等高层功能。而存储引擎（如InnoDB、MyISAM）是其底层组件，专门负责数据的物理存储、索引管理、事务实现等具体操作。</p>
</li>
<li><p><strong>索引怎么实现的</strong></p>
</li>
<li><p><strong>为什么用B+树，不用二叉树</strong></p>
</li>
<li><p><strong>B+树时间复杂度为什么是O(logN)</strong><br> 每次查找从根节点开始，通过二分法定位子节点指针，只需访问h个节点即可到达叶子节点。</p>
</li>
<li><p><strong>联合索引 (a,b,c) (b,a,c) (c,b,a) 有什么区别</strong><br> 联合索引的字段顺序决定了数据的物理排序方式<br> **<code>(a,b,c)</code>**：先按 <code>a</code> 排序，<code>a</code> 相同再按 <code>b</code> 排序，最后按 <code>c</code> 排序。影响索引的 <strong>最左匹配原则</strong> 和查询效率</p>
</li>
<li><p><strong>联合索引把什么样的字段放在第一个（用户登录状态和uid哪个放第一个）</strong><br> 把区分度高的字段放在第一个</p>
</li>
<li><p><strong>事务隔离级别，可重复读有没有幻读现象，什么情况下出现幻读</strong><br> 幻读是指一个事务在两次查询中得到的结果集不同，原因是另一个事务在两次查询之间插入或删除了数据。</p>
</li>
<li><p><strong>Redis持久化方式，快照怎么实现的</strong><br> 第一步是当触发 RDB 持久化时，Redis 会 fork 出一个子进程；<br> 第二步是子进程负责将当前内存中的数据完整地写入到一个临时文件中；<br> 第三步是在写入完成后，子进程用这个临时文件替换掉旧的 RDB 文件，完成持久化。</p>
</li>
<li><p><strong>快照怎么保证和上一个快照不冲突（提示有个静态变量，？）</strong></p>
</li>
</ol>
<p>反问<br>秒挂的</p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
  </entry>
  <entry>
    <title>众安保险后端一面(AIGC部门)</title>
    <url>/2025/04/18/%E9%9D%A2%E7%BB%8F/%E4%BC%97%E5%AE%89%E4%BF%9D%E9%99%A9%E5%90%8E%E7%AB%AF%E4%B8%80%E9%9D%A2-AIGC%E9%83%A8%E9%97%A8/</url>
    <content><![CDATA[<p>0418 第二次面试，30min，面试官超好，但自己太菜了<br>根据我的回答来问的，几乎没八股。</p>
<span id="more"></span>

<p>自我介绍（说要偏向项目的介绍）</p>
<ol>
<li>项目里遇到的最大的问题（说了Redis和数据库缓存不一致的问题）</li>
<li>根据我的回答深挖，这种情况为什么不一致（还安慰我不要紧张）</li>
<li>不断的提示，发现我说的问题不会导致Redis和数据库缓存不一致，而是在分布式的情况下，会出现不一致。</li>
<li>又更正我，在更新完Redis， 更新数据库前网络中断了，才会导致数据库没更新上。</li>
<li>再问还遇到了什么问题（没好好准备）</li>
<li>提到ThreadLocal，说用完不释放的话会导致内存泄漏</li>
<li>问还有什么问题，多台机器怎么办，提示可以存数据库里</li>
<li>又问有没有遇到数据库索引相关的问题</li>
<li>什么时候要加索引，什么时候不加索引</li>
<li>索引失效的情况</li>
<li>问自己有没有遇到过索引失效的情况，提示他们常见的很难排查的是 隐式类型转换让索引失效</li>
<li>出了个写sql的题（我是fw，一定好好练sql语句）</li>
<li>表里有两个字段，一个字段是类型（A,B,C,D,E），一个字段是数量，写一个sql语句求出每个类型的数量（提示的）<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">SELECT</span> 类型, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> 数量</span><br><span class="line">	<span class="keyword">FROM</span> 表名</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> 类型;</span><br><span class="line">  </span><br><span class="line"><span class="number">14.</span> 第二个<span class="keyword">sql</span>根据第一个<span class="keyword">sql</span>，上一个<span class="keyword">sql</span>查出来的是五行二列，那么怎么变成一行十列（面试官直接告诉我答案了）</span><br><span class="line">```<span class="keyword">sql</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="built_in">MAX</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> 类型 <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span> <span class="keyword">THEN</span> 数量 <span class="keyword">END</span>) <span class="keyword">AS</span> A_数量,</span><br><span class="line">    <span class="built_in">MAX</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> 类型 <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span> <span class="keyword">THEN</span> 数量 <span class="keyword">END</span>) <span class="keyword">AS</span> B_数量,</span><br><span class="line">    <span class="built_in">MAX</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> 类型 <span class="operator">=</span> <span class="string">&#x27;C&#x27;</span> <span class="keyword">THEN</span> 数量 <span class="keyword">END</span>) <span class="keyword">AS</span> C_数量,</span><br><span class="line">    <span class="built_in">MAX</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> 类型 <span class="operator">=</span> <span class="string">&#x27;D&#x27;</span> <span class="keyword">THEN</span> 数量 <span class="keyword">END</span>) <span class="keyword">AS</span> D_数量,</span><br><span class="line">    <span class="built_in">MAX</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> 类型 <span class="operator">=</span> <span class="string">&#x27;E&#x27;</span> <span class="keyword">THEN</span> 数量 <span class="keyword">END</span>) <span class="keyword">AS</span> E_数量</span><br><span class="line"><span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure></li>
<li>多线程里用过哪些（回答了加锁）</li>
<li>什么情况要加锁，想一个场景（自己想的场景有个坑，面试官又给我提示了一下）</li>
</ol>
<p>反问</p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
  </entry>
  <entry>
    <title>得物20250419笔试</title>
    <url>/2025/04/19/%E7%AC%94%E8%AF%95%E9%A2%98/%E5%BE%97%E7%89%A920250419%E7%AC%94%E8%AF%95/</url>
    <content><![CDATA[<p>单选20道40分，编程题3道60分，测评20道2分<br>2h，编程题限制用Java写</p>
<span id="more"></span>

<h1 id="单选题"><a href="#单选题" class="headerlink" title="单选题"></a>单选题</h1><ol>
<li>陷阱和中断<br> 中断由外部硬件触发，陷阱由程序主动调用或出现异常或系统调用触发<br> 线程切换更多由中断触发</li>
<li>哈希表平均查找长度<br> 平均查找长度 &#x3D; （所有关键字查找长度之后）&#x2F; 关键字数量</li>
<li>给一棵二叉树，用DFS遍历，求栈大小最小多少能完成DFS</li>
<li>数据库主键<br> 主键不能为空值</li>
<li>volatile 关键字<br> 不是线程安全的，不保证原子性</li>
<li>LRU，缺页几次，大小为4页，1 3 2 4 5 3 1 2</li>
<li>代码运行结果<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;  </span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);  </span><br><span class="line">System.out.println(a == b); <span class="comment">// false  </span></span><br><span class="line">System.out.println(b == <span class="number">100</span>); <span class="comment">// true 自动拆箱比较的是100==100</span></span><br></pre></td></tr></table></figure></li>
<li>ArrayList 和 LinkedList区别</li>
<li>语法分析，终结符和非终结符</li>
<li>deque程序调用哪个方法会编译错误<br>get，不支持随机访问</li>
<li>继承和抽象代码运行结果</li>
<li>订单系统，失效就取消订单，哪个设计模式适合这个流程</li>
<li>HashSet 和 TreeSet<br>TreeSet 不能存入NUll值，TreeSet 存的是有序值，NULL无法和其他值比较</li>
<li>堆排序</li>
<li>IP 协议（网络层）</li>
<li>ABCDEF 按顺序进展，不能连续出栈3次，什么顺序是错误的<br>CFEDBA</li>
<li>数据库什么情况会数据泄漏<br>权限设置不当</li>
<li>IP组播<br>IP组播使用D类地址（224.0.0.0~239.255.255.255）作为目标地址。</li>
<li>面向对象的设计准则</li>
<li>sql语句，一个竞赛表（学号、姓名、分数）一个晋级表（排名，学号），查询未晋级学生的学号姓名<br>NOT IN、NOT EXIST、LEFT JOIN、RIGHT JOIN<br>左连接是保留左表所有记录，即使右表中没有匹配</li>
</ol>
<h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h1><p> 都写出来了，Java的输入不太熟</p>
<ol>
<li>给定一个数，构造一个三行三列的行列式，值等于这个数</li>
<li>对一个数组，可以执行无数次操作，最少执行多少次，让数组变成都是0，操作：选一些元素，减少 2^k 次方。</li>
<li>n行m列字符矩阵，q次询问，每次询问输入a,b,c，向左移位a次，b行c列的字符是什么。</li>
</ol>
]]></content>
      <categories>
        <category>笔试题</category>
      </categories>
  </entry>
  <entry>
    <title>饿了么20250419笔试</title>
    <url>/2025/04/20/%E7%AC%94%E8%AF%95%E9%A2%98/%E9%A5%BF%E4%BA%86%E4%B9%8820250419%E7%AC%94%E8%AF%95/</url>
    <content><![CDATA[<p>单选8题24分、不定项7题21分、编程题3道55分</p>
<p>好难，A了1.2道QAQ，一周末做四个笔试，脑子都不转了</p>
<span id="more"></span>

<h1 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h1><ol>
<li>sql题，xxx count(4) 和 xxx count(7) 的执行结果<br> <code>count(*)、count(常量）</code> 都是统计所有行数<br> <code>count(列名)</code> 统计该列不为空的行数</li>
<li>图形推理</li>
<li>陷阱和中断（陷阱是同步的，中断是异步的）</li>
<li>树转成二叉树，后续遍历的结果<br> 转换方法：左孩子-右兄弟</li>
<li>常识题</li>
<li>IP 数据报（不包含窗口字段）</li>
<li>linux 中计算文件单词个数的命令<br> wc【选项】文件名<br> -w （word）统计单词数<br> -l 统计行数<br> -c 统计字节数</li>
<li>日志记录系统，生成新日志是，告知所有关联该日志的开发者，用什么设计模式（观察者模式）</li>
</ol>
<h1 id="不定项"><a href="#不定项" class="headerlink" title="不定项"></a>不定项</h1><ol>
<li>TCP 流量控制和拥塞控制<br> 发送窗口大小 &#x3D; min(拥塞窗口, 接收方窗口)<br> 拥塞窗口是动态变化的<br> 流量控制是端到端的，拥塞控制是全局的</li>
<li>Linux命令<br> cat本身是查看命令，可以利用重定向创建文件</li>
<li>建造者模式（将对象的构建步骤拆解）</li>
<li>不是原地排序的算法<br> 归并和基数（基数排序要用到桶，先按个位排序，再收集；按十位排序再收集；最后一次收集就是有序的）</li>
<li>块设备和字符设备<br> 块设备传输数据块，速度快，可寻址（硬盘、SSD）<br> 字符串传输字符，速度慢，一般顺序访问（键盘鼠标）</li>
<li>入栈顺序、出栈顺序</li>
<li>索引失效的场景</li>
</ol>
<h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h1><p>A了1.2道QAQ，还是得物的简单</p>
<ol>
<li>模拟，有a,b,c三个数组，a中任意下标元素ai可以转换成b中的ci下标的元素，求一个式子最小</li>
<li>输入数字字符串，求所有子序列的分数，合法子序列为最后一位是偶数，并且无前缀0，以8为结尾的子序列2分，其余子序列1分。</li>
<li>求x和y的最小公倍数，g(x,y)是最小公倍数从低位到高位遇到的第一个非零数字和最后位之间0的个数，1&lt;&#x3D;i&lt;&#x3D;j&lt;&#x3D;n，求g(ai,aj)的总和</li>
</ol>
]]></content>
      <categories>
        <category>笔试题</category>
      </categories>
  </entry>
  <entry>
    <title>海康威视0420笔试</title>
    <url>/2025/04/20/%E7%AC%94%E8%AF%95%E9%A2%98/%E6%B5%B7%E5%BA%B7%E5%A8%81%E8%A7%860420%E7%AC%94%E8%AF%95/</url>
    <content><![CDATA[<p>25道单选50分，10道多选30分，两道编程题20分</p>
<span id="more"></span>

<h1 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h1><ol>
<li>正则表达式匹配</li>
<li>程序运行结果<br>num1 和 num2 指向的是同一个对象<br>Java 中方法始终的值传递，传递的是引用的副本<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">    <span class="type">Integer</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);  </span><br><span class="line">    <span class="type">Integer</span> <span class="variable">num2</span> <span class="operator">=</span> num1;  </span><br><span class="line">    work(num2);  </span><br><span class="line">    System.out.println(num1.intValue());  <span class="comment">// 1</span></span><br><span class="line">    System.out.println(num1 == num2);   <span class="comment">// true</span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(Integer integer)</span> &#123;  </span><br><span class="line">    integer = <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>StampLock（不是可重入锁）<br>如果一个线程已经持有写锁（<code>writeLock</code>），再次尝试获取同一把锁会导致<strong>死锁</strong></li>
<li>哪个不是字节流类型<br> FileOutputStream、FileInputStream、InputStreamReader（字符流Reader、Writer）、ByteArrayInputStream</li>
<li>Lambda表达式作用（简化函数式接口实现）</li>
<li>接口的default方法（可以被调用，可以被覆盖实现）</li>
<li>未认证是哪个状态码（401，请求需要身份认证）</li>
<li>AVL树</li>
<li>sql 语句</li>
<li>zset添加成员并设置分数的命令（zadd）</li>
<li>什么不是关系型数据库（MongoDB）</li>
<li>统计网站当前在线人数，count保存的范围是（application）</li>
<li>web开发，数据跨请求存储在哪里</li>
<li>servlet生命周期（加载类、实例化、初始化、请求、销毁）</li>
<li>spring事务传播行为（REQUIRES_NEW无论是否当前是否存在事务，都会创建一个独立的新事务）</li>
<li>判断是什么数据结构（B(D,R) D{a,b,c,d,e}, R{(a,b),(b,c),(c,d),(d,e),(e,a)} 环形链表）</li>
<li>代码执行结果<br>输出是1，1  靠的是类加载和静态变量初始化的顺序，静态变量按声明顺序初始化<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">test</span>();  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> a;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;  </span><br><span class="line">    test() &#123;  </span><br><span class="line">        a++;  </span><br><span class="line">        b++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> test <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> t;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">test</span> <span class="variable">t</span> <span class="operator">=</span> test.t.getInstance();  </span><br><span class="line">        System.out.println(t.a + <span class="string">&quot; &quot;</span> + t.b);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>异常<br>子类方法抛出的异常范围不能大于父类方法声明的异常范围<br>try-catch，也能捕获Error，但不推荐</li>
<li>有序单链表插入一个节点的时间复杂度</li>
<li>TCP和UDP区别</li>
<li>Java序列化<br>PrinterWriter不能用于对象序列化输出</li>
<li>程序运行结果<br>会编译错误，final修饰的变量一旦赋值，不能被改变<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printstr</span><span class="params">(<span class="keyword">final</span> String str)</span> &#123;  </span><br><span class="line">    str = str + <span class="string">&quot;!!&quot;</span>;  </span><br><span class="line">    System.out.println(str);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>&amp;和&amp;&amp;</li>
<li>异常（异常是一种对象，JVM会自动创建）</li>
<li>Having作用（对分组后的结果筛选）</li>
</ol>
<h1 id="多选"><a href="#多选" class="headerlink" title="多选"></a>多选</h1><ol>
<li>Spring<br>  配置文件能设置Bean初始化函数和消亡函数<br>  属性注入可以是简单数据也可以是对象，构造注入可以是对象<br>  能设置Bean延迟加载</li>
<li>读配置注解<br>  @Value、@ConfigurationProperties、@PropertySource 和 Environment接口</li>
<li>数据引擎要考虑的因素（并发行、查询复杂度、扩展性和可靠性）</li>
<li>Email相关的协议（SMTP、POP3、IMAP、MIME）</li>
<li>final<br>  修饰类时，不能被继承<br>  修饰方法时，不能被重写<br>  修饰变量时，不能被改变</li>
<li>线程不能运行三种原因（休眠、等待、阻塞）</li>
<li>反射功能<br>运行时判断一个对象的类，获取一个类的成员变量</li>
<li>Object类中的方法<br> getClass、clone、equals</li>
<li>inner join、left join、right join<br> 内连接只返回两表都有的数据</li>
<li>bean中的作用域</li>
</ol>
<h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h1><p>都A了</p>
<ol>
<li>最长子序列</li>
<li>SQL题，一个公司表（公司ID，公司名），一个用户表（用户ID，用户名，邮箱，公司ID），一个设备表（设备ID，设备名，公司ID，在线状态），根据用户email，查出设备<br> 两个join，一开始写的只过40%，后来灵机一动，筛选条件里加上设备状态为在线的就过了<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> u.user_name, c.company_name,d.device_name</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span> u</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> company c <span class="keyword">on</span> u.company_id <span class="operator">=</span> c.id</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> device d <span class="keyword">on</span> c.id <span class="operator">=</span> device.company_id</span><br><span class="line"><span class="keyword">where</span> u.email <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span> <span class="keyword">and</span> device.online <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>笔试题</category>
      </categories>
  </entry>
  <entry>
    <title>pdd服务端研发一面</title>
    <url>/2025/04/26/%E9%9D%A2%E7%BB%8F/pdd%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A0%94%E5%8F%91%E4%B8%80%E9%9D%A2/</url>
    <content><![CDATA[<p>0425 问了些八股（10min），没问项目，做了三题手撕（50min）<br>在pdd的面试平台，需要共享屏幕。面试官很和蔼，比约的时间早进面试间。<br>不会的也说没事，手撕也提示</p>
<span id="more"></span>

<p>自我介绍（1min）</p>
<ol>
<li>常见的集合有哪些</li>
<li>哈希表有哪些实现方式</li>
<li>除了哈希表，还有什么数据结构能实现输入key，找到他的value<br> 位图、布隆过滤器能查key是否存在<br> 前缀树找字符串是否存在<br> 跳表、平衡树找有序数据</li>
<li>哈希表怎么实现的</li>
<li>为什么链表长度大于8，要用红黑树</li>
<li>为什么红黑树是log(n)的时间复杂度</li>
<li>优先队列怎么实现的</li>
<li>说一下堆怎么实现的，pop之后堆怎么调整</li>
<li>说一下TCP协议</li>
<li>说一下IP协议</li>
<li>说一下HTTP协议和TCP&#x2F;IP整体关系</li>
<li>说一下HTTPS</li>
<li>说一下HTTPS的原理</li>
<li>说一下公钥、私钥和数字证书</li>
<li>为什么一开始要用非对称加密，后来用对称加密</li>
<li>HTTPS 如何防范中间人攻击</li>
</ol>
<p>手撕</p>
<ol>
<li>给了两个有序的数组（数组中有重复元素），把a中存在，但b中不存在的数据加入新数组</li>
<li>一个有序序列构造成二叉搜索树有很多种结构，如何判断两个二叉搜索树是一样的。<br> 先说了中序遍历获得序列判断，但面试官提示说能不能一边遍历一边判断，比如最小的数不相等就不往下遍历了</li>
<li>给一个字符数组，写一个排序函数，数字排在字母前面，但数字之间相对顺序不变，字母之间相对顺序不变。（原地排序，不能用新数组）</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
  </entry>
</search>
